// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "HAL/Platform.h"

#include "CoreTypes.h"
#include "CoreGlobals.h"
#include "Templates/SharedPointer.h"
#include "IElectraTextureSample.h"
#include "Math/IntPoint.h"
#include "Math/Range.h"
#include "Misc/Timespan.h"
#include "MediaObjectPool.h"
#include "MediaSamples.h"
#include "MediaVideoDecoderOutputAndroid.h"

#define UE_API ELECTRASAMPLES_API

class FElectraTextureSampleSupport;
class FEvent;
struct AHardwareBuffer;

/**
 * Texture sample generated by AndroidMedia player.
 */
class FElectraTextureSample final
	: public IElectraTextureSampleBase
	, public IMediaTextureSampleConverter
	, public TSharedFromThis<FElectraTextureSample, ESPMode::ThreadSafe>
{
public:

	/** Default constructor. */
	FElectraTextureSample(TSharedPtr<FElectraTextureSampleSupport, ESPMode::ThreadSafe> InSupport)
	: Support(InSupport)
	, ImageResources(nullptr)
	, Texture(nullptr)
	, Buffer(nullptr)
	, BufferSize(0)
	{
	}

	/** Virtual destructor. */
	UE_API virtual ~FElectraTextureSample();

#if !UE_SERVER
	UE_API virtual bool IsReadyForReuse() override;
	UE_API virtual void ShutdownPoolable() override;
#endif

	UE_API void Initialize(FVideoDecoderOutput* InVideoDecoderOutput);

	//~ IMediaTextureSample interface

	virtual const void* GetBuffer() override
	{
		return Buffer;
	}

	UE_API virtual EMediaTextureSampleFormat GetFormat() const override;

	UE_API virtual uint32 GetStride() const override;

	virtual FRHITexture* GetTexture() const override
	{
		return Texture.GetReference();
	}

	virtual IMediaTextureSampleConverter* GetMediaTextureSampleConverter() override
	{
		return this;
	}

private:
	friend class FElectraTextureSampleSupport;

	UE_API FTextureRHIRef InitializeTextureOES(AHardwareBuffer* HardwareBuffer);
	UE_API FTextureRHIRef InitializeTextureVulkan(AHardwareBuffer* HardwareBuffer);

	UE_API void InitializeTexture(EPixelFormat PixelFormat);
	UE_API void SetupFromBuffer(const void* InBuffer, int32 InBufferSize);
	UE_API void SetImageResources(jobject InImageResources);
	UE_API void CleanupImageResources();
	UE_API void CopyFromExternalTextureOES(FRHICommandListImmediate& RHICmdList, FTextureRHIRef& InDstTexture, FTextureRHIRef& InSrcTexture, const FVector2f& Scale, const FVector2f& Offset);
	UE_API void CopyFromExternalTextureVulkan(FRHICommandListImmediate& RHICmdList, FTextureRHIRef& InDstTexture, FTextureRHIRef& InSrcTexture, const FVector2f& InScale, const FVector2f& InOffset);

	UE_API virtual bool Convert(FRHICommandListImmediate& RHICmdList, FTextureRHIRef& InDstTexture, const FConversionHints& Hints) override;
	UE_API bool ConvertCpuOutputPath(FRHICommandListImmediate& RHICmdList, FTextureRHIRef& InDstTexture, const FConversionHints& Hints);
	UE_API bool ConvertGpuOutputPath(FRHICommandListImmediate& RHICmdList, FTextureRHIRef& InDstTexture, const FConversionHints& Hints);

	virtual uint32 GetConverterInfoFlags() const
	{
		return ConverterInfoFlags_Default;
	}

	TSharedPtr<FElectraTextureSampleSupport, ESPMode::ThreadSafe> Support;

	FVideoDecoderOutputAndroid* VideoDecoderOutputAndroid;

	bool UseGpuOutputPath;

	void* Buffer;
	int32 BufferSize;

	/** Texture resource. */
	TRefCountPtr<FRHITexture> Texture;

	jobject ImageResources;
	bool bQueuedForConversion;

	TRefCountPtr<FRHIGPUFence> Fence;
};


using FElectraTextureSamplePtr  = TSharedPtr<FElectraTextureSample, ESPMode::ThreadSafe>;
using FElectraTextureSampleRef  = TSharedRef<FElectraTextureSample, ESPMode::ThreadSafe>;

class FElectraTextureSamplePool : public TMediaObjectPool<FElectraTextureSample, FElectraTextureSamplePool>
{
	using TextureSample = FElectraTextureSample;

public:
	UE_API FElectraTextureSamplePool();

	TextureSample* Alloc() const
	{
		return new TextureSample(Support);
	}

	UE_API void* GetCodecSurface();

private:
	TSharedPtr<FElectraTextureSampleSupport, ESPMode::ThreadSafe> Support;
};

#undef UE_API
