<?xml version='1.0' ?>
<BuildGraph xmlns="http://www.epicgames.com/BuildGraph" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.epicgames.com/BuildGraph ../Schema.xsd" >
	<EnvVar Name="UE_HORDE_JOBID"/>
	<EnvVar Name="UE_HORDE_STEPID"/>
	<EnvVar Name="UE_HORDE_TEMPLATEID"/>
	<EnvVar Name="UE_HORDE_LAST_WARNING_CL"/>
	
	<EnvVar Name="UE-CloudPublishHost"/>
	<EnvVar Name="UE-CloudPublishHttpVersion"/>
	<EnvVar Name="UE-CloudPublishDescriptorHost"/>
	<EnvVar Name="UE-CloudPublishDescriptorHttpVersion"/>
	<EnvVar Name="UE-CloudPublishNamespace"/>
	<EnvVar Name="UE-CloudPublishBaselineBranch"/>
	<EnvVar Name="UE-ZenPublishHost"/>

	<Property Name="IsHordeEnv" Value="false"/>
	<Property Name="IsHordeEnv" Value="true" If="'$(UE_HORDE_JOBID)' != ''"/>
	<Option Name="Horde" DefaultValue="$(IsBuildMachine) And $(IsHordeEnv)" Description="Whether the build is running under Horde"/>
	
	<!-- Project Options -->
	<Option Name="ProjectFile" DefaultValue="" Restrict=".*" Description="Path to the project file. Can be used instead of specifying ProjectName and ProjectPath separately."/>

	<Property Name="DefaultProjectName" Value="None"/>
	<Property Name="DefaultProjectPath" Value="None"/>
	<Regex Input="$(ProjectFile)" Pattern="(.*)[/\\]([^/\\]+)\.uproject" Capture="DefaultProjectPath;DefaultProjectName" If="'$(ProjectFile)' != ''"/>

	<Option Name="ProjectName" DefaultValue="$(DefaultProjectName)" Restrict=".+" Description="Name of Project"/>
	<Option Name="ProjectPath" DefaultValue="$(DefaultProjectPath)" Restrict=".+" Description="Path to the folder that contains your project"/>

	<Option Name="IsContentOnlyProject" DefaultValue="false" Restrict="true|false" Description="Is the project a content only project?"/>	

	<Option Name="TargetName" DefaultValue="" Restrict="" Description="If your project supports both Game and Client you can set this, otherwise one will be selected"/>
	<Option Name="EditorTargetName" DefaultValue="" Restrict="" Description="Specify the editor target name if different than (ProjectName)Editor"/>
	<Option Name="CookedEditorTargetName" DefaultValue="" Restrict="" Description="Specify the cooked editor target name if different than (ProjectName)CookedEditor"/>

	<Option Name="PreNodeName" DefaultValue="$(ProjectName)" Description="String to prepend to node name"/>
	<Option Name="PreLabelName" DefaultValue="" Description="String to prepend to label name"/>
	<Property Name="PreNodeName" Value="$(PreNodeName) " If="'$(PreNodeName)' != ''"/>
	<Property Name="PreLabelName" Value="$(PreLabelName) " If="'$(PreLabelName)' != ''"/>

	<Option Name="GenericCompileArguments" DefaultValue="" Restrict="" Description="Configurable compile args applied to all compile targets."/>
	<Option Name="ExtraToolCompileArguments" DefaultValue="" Restrict="" Description="Extra arguments to use when building the tools" />
	<Option Name="ExtraEditorCompileArguments" DefaultValue="" Restrict="" Description="Extra arguments to use when building the editor" />
	<Option Name="ExtraTargetCompileArguments" DefaultValue="" Restrict="" Description="Extra arguments to use when building targets" />
	<Option Name="MapIniSection" DefaultValue="" Restrict="" Description="MapIniSection argument to pass when cooking" />
	<Option Name="ExtraCookArguments" DefaultValue="" Restrict="" Description="Extra arguments to use when cooking" />
	<Option Name="ExtraStageAndPackageArguments" DefaultValue="" Restrict="" Description="Extra arguments to use when staging and packaging" />
	<Option Name="ExtraPackageOnlyArguments" DefaultValue="" Restrict="" Description="Extra arguments to use when staging only" />	
	<Option Name="TargetPlatformFilteredExtraStageAndPackageArguments" DefaultValue="" Restrict="" Description="Extra arguments to use when staging and packaging.  Filtered to specific platforms via TargetPlatformFilteredExtraStageAndPackageArgumentsFilter." />
	<Option Name="TargetPlatformFilteredExtraStageAndPackageArgumentsFilter" DefaultValue="" Restrict="" Description="Platform filter applied to TargetPlatformFilteredExtraStageAndPackageArguments." />
	<Option Name="WithRemoteExecWorkers" DefaultValue="false" Restrict="" Description="If your project uses standalone remote execution workers" />
	<Option Name="WithInterchangeWorker" DefaultValue="false" Restrict="" Description="To compile Interchange Worker in Compile Tools node" />
	<Option Name="UseIncrementalAgents" DefaultValue="false" Restrict="true|false" Description="Use incremental agents for building" />
	<Option Name="AgentOverride" DefaultValue="" Description="If set, other logic is ignored and this agent type is used for all non-test work." />
	<Option Name="TestAgentOverride" DefaultValue="" Description="If set, other logic is ignored and this agent type is used for all test work." />
	<Option Name="TargetPlatformTestAgentOverride" DefaultValue="DevkitAutomation" Description="Override agent type use to run target platform tests"/>
	<Option Name="ClientCompileAgentOverride" DefaultValue="" Description="Specifies the agent type to use for C++ compilation jobs for target platform binaries." />
	<Option Name="DontUseTestAgent" Restrict="true|false" DefaultValue="false" Description="Avoid using test agent pool to run tests"/>
	<Option Name="UnrealInsightsBuildConfiguration" DefaultValue="Shipping" Restrict="Development|Debug|Shipping" Description="In which configuration to build Unreal Insights, if included. Shipping, Debug, or Development." />
	<Option Name="IncludeUnrealInsightsInToolCompile" DefaultValue="false" Description="Include Unreal Insights into Compile Tools prerequisites" />
	<Option Name="IncludeEpicWebHelperInToolCompile" DefaultValue="false" Description="Include EpicWebHelper into Compile Tools prerequisites" />
	<Option Name="WithDeviceReservation" DefaultValue="$(Horde)" Description="Whether to re-use devices and installed builds for a sequence of tests, where supported"/>
	<Option Name="DoGPUReshape" DefaultValue="false" Restrict="true|false" Description="Whether to run GPU instrumentation test with GPU Reshape." />

	<!-- 
		Allow project graphs that Include this file to specify their own defaults.
	-->
	<Option Name="DefaultEditorPlatforms" DefaultValue="" Description="Default Editor platforms"/>
	<Option Name="DefaultCookedEditorPlatforms" DefaultValue="" Description="Default Cooked Editor platforms"/>
	<Option Name="DefaultTargetPlatforms" DefaultValue="" Description="Default Target platforms"/>
	<Option Name="DefaultTargetConfigurations" DefaultValue="Development" Description="Default Target configurations"/>
	<Option Name="DefaultCookedEditorConfigurations" DefaultValue="Development" Description="Default Cooked Editor configurations"/>
	<Option Name="DefaultEditorTestList" DefaultValue="" Description="Default Editor test list"/>
	<Option Name="DefaultTargetTestList" DefaultValue="" Description="Default Target test list"/>
	<Option Name="DefaultCookedEditorTestList" DefaultValue="" Description="Default Cooked Editor test list"/>
	<Option Name="NetworkTempRootOverride" DefaultValue="" Description="Network temp root override"/>
	<Option Name="NetworkPublishRootOverride" DefaultValue="" Description="Network publish root override"/>
	<Option Name="NetworkReportRootOverride" DefaultValue="" Description="Network report root override"/>
	<Option Name="SymbolServerPath" DefaultValue="" Description="Symbol server path"/>

	<Option Name="PublishCloudSnapshot" DefaultValue="false" Restrict="true|false" Description="Publish build to cloud host" />
	<Option Name="PublishZenSnapshot" DefaultValue="false" Restrict="true|false" Description="Publish build to zen host" />

	<Option Name="EnableSymbolStore" DefaultValue="$(IsBuildMachine)" Restrict="true|false" Description="Enables the upload of debugging symbols" />
	<Property Name="SymbolServerPath" Value="" If="$(EnableSymbolStore) == 'false'" />

	<Option Name="CheckBuildSizePlatforms" DefaultValue="" Description="List of Platforms to CheckBuildSize on, format is Name:000000 separated by ;" />

	<!-- This will define options for all platforms and create lists called EditorPlatforms, RequiredEditorPlatforms, and TargetPlatforms. E.g. TargetPlatforms=Win64+Mac+Android -->
	<Include Script="Inc/PlatformOptions.xml" />

	<!-- For compatibility with build graphs relying on PlatformsToSkipTests option from PlatformOptions that was replaced with Editor/Target specific options -->
	<Do If="'$(PlatformsToSkipTests)' != ''" >
		<Property Name="EditorPlatformsToSkipTests" Value="$(PlatformsToSkipTests)" />
		<Property Name="TargetPlatformsToSkipTests" Value="$(PlatformsToSkipTests)" />
		<Property Name="CookedEditorPlatformsToSkipTests" Value="$(PlatformsToSkipTests)" />
		<Property Name="EditorPlatformsToSkipBootTests" Value="$(PlatformsToSkipTests)" />
		<Property Name="TargetPlatformsToSkipBootTests" Value="$(PlatformsToSkipTests)" />
		<Property Name="CookedEditorPlatformsToSkipBootTests" Value="$(PlatformsToSkipTests)" />
	</Do>

	<!-- Does this project require a dedicated server for testing? (not currently implemented!)-->
	<Option Name="DedicatedServer" DefaultValue="false" Description="Project uses a dedicated server" />

	<!-- Customizations -->
	<Option Name="Versioned" Restrict="true|false" DefaultValue="false" Description="Whether to embed changelist number into binaries"/>
	<Option Name="SkipBuild" DefaultValue="false" Description="Whether to skip building" />
	<Option Name="SkipCook" DefaultValue="false" Description="Whether to skip cooking and packaging" />
	<Option Name="SkipPackage" DefaultValue="false" Description="Whether to skip packaging" />
	<Option Name="SkipPublish" DefaultValue="false" Description="Whether to skip cooking, packaging, publishing" />
	<Option Name="SkipTest" DefaultValue="false" Description="Whether to skip testing" />

	<!-- Defines whether we always run a simple 'does it boot' test before running other tests. This can save a lot of time/repeated errors -->
	<Option Name="EditorBootTest" DefaultValue="!$(SkipTest)" Description="Run a simple boot test on the editor before other tests"/>
	<Option Name="TargetBootTest" DefaultValue="!$(SkipTest)" Description="Run a simple boot test on target platforms before other tests"/>
	<Option Name="CookedEditorBootTest" DefaultValue="!$(SkipTest)" Description="Run a simple boot test on cooked editor platforms before other tests"/>

	<Option Name="FillEditorDDC" DefaultValue="false" Description="Whether to fill the editor DDC before running any editor tests"/>

	<Option Name="EditorTestList" DefaultValue="$(DefaultEditorTestList)" Description="Tests to run on the editor. Test1+Test2 etc"/>
	<Option Name="TargetTestList" DefaultValue="$(DefaultTargetTestList)" Description="Tests to run on the target platform(s). Test1+Test2 etc"/>
	<Option Name="CookedEditorTestList" DefaultValue="$(DefaultCookedEditorTestList)" Description="Tests to run on the cooked editor. Test1+Test2 etc"/>
	<Option Name="EditorPlatformsToSkipBootTests" DefaultValue="$(EditorPlatformsToSkipTests)" Description="Editor platforms that should skip boot tests."/>
	<Option Name="TargetPlatformsToSkipBootTests" DefaultValue="$(TargetPlatformsToSkipTests)" Description="Target platforms that should skip boot tests."/>
	<Option Name="CookedEditorPlatformsToSkipBootTests" DefaultValue="$(CookedEditorPlatformsToSkipTests)" Description="Cooked editor platforms that should skip boot tests."/>
	<Option Name="RequiringEditorTargetTestList" DefaultValue="" Description="List of tests that require the editor to run. Test1+Test2 etc. Match is partial"/>

	<!-- Macro that allows adding additional per-platform, per-configuration test nodes -->
	<!-- Expand the macro inside the AdditionalTestNodesExtendFile --> 
	<Option Name="AdditionalTestNodesExtendFile" DefaultValue="" Description="For extend the AdditionalTestNodes Macro" />
	<Macro Name="AdditionalTestNodes" />
	<Do If="'$(AdditionalTestNodesExtendFile)' != ''">
		<Error Message="$(AdditionalTestNodesExtendFile) does not seem to exist" If="!Exists('$(AdditionalTestNodesExtendFile)')" />
		<Include Script="$(AdditionalTestNodesExtendFile)" />
	</Do>

	<Option Name="TestsRequireEditor" DefaultValue="false" Description="Whether to force tests to require editor compilation"/>

	<!-- Macros that allows custom pre-steps -->
	<Macro Name="PreCookStep"/>
	
	<!-- Macros that allow custom post tests steps -->
	<Option Name="PostEditorTestsExtendFile" DefaultValue="" Description="Path to the file containing all post editor tests macro extends"/>
	<Macro Name="PostEditorTestsStep"/>
	<Do If="'$(PostEditorTestsExtendFile)' != ''">
		<Error Message="Post Editor Tests Extend File $(PostEditorTestsExtendFile) does not exist" If="!Exists('$(PostEditorTestsExtendFile)')"/>
		<Include Script="$(PostEditorTestsExtendFile)"/>
	</Do>

	<!-- Settings files that can be overriden -->
	<Option Name="PathSettingsFile" DefaultValue="Inc/PathSettings.xml" Description="Path settings to use" />
	<Option Name="GauntletSettingsFile" DefaultValue="Inc/GauntletSettings.xml" Description="Gauntlet settings to use" />
	<Option Name="PreStepsExtendFile" DefaultValue="" Description="Path to the file containing all pre-step macro extends"/>

    <!-- Annotations notif settings -->
	<Option Name="AnnotationsTarget" DefaultValue="" Description="Set annotations target" />
	<Option Name="AnnotationsPlatforms" DefaultValue="" Description="List of platforms that require annotations"/>
	<Option Name="AnnotationsTests" DefaultValue="" Description="List of tests that require annotations"/>

	<!-- Default common properties -->
	<Include Script="Inc/CommonProperties.xml" />

	<!-- Common settings but can be overidden -->
	<Option Name="UseNetworkShare" DefaultValue="$(IsBuildMachine)" Restrict="true|false" Description="Whether to use network share for build output"/>
	<Include Script="$(PathSettingsFile)" />
	<Include Script="$(GauntletSettingsFile)" />
	<Do If="'$(PreStepsExtendFile)' != ''">
		<Error Message="Pre Steps Extend file $(PreStepsExtendFile) does not exist" If="!Exists('$(PreStepsExtendFile)')"/>
		<Include Script="$(PreStepsExtendFile)"/>
	</Do>

	<!-- Test configs -->
	<Include Script="Inc/TestConfigs.xml"/>
	<Do If="'$(TestConfigList)' == ''">
		<Expand Name="AddTestConfig" TestConfigName=""/>
	</Do>

	<!-- Add known target test types that require the editor -->
	<Property Name="RequiringEditorTargetTestList" Value="$(RequiringEditorTargetTestList)+UE.TargetAutomation+Cook"/>

	<!-- At this point we have all options so calculate a few things -->

	<!-- Validate that the project exists-->
	<Error Message="ProjectName and ProjectPath must be specified" If="'$(ProjectName)' == 'None' or '$(ProjectPath)' == 'None'" />
	<Property Name="TargetProject" Value="$(ProjectPath)/$(ProjectName).uproject" />
	<Error Message="Project file $(TargetProject) does not exist" If="!Exists('$(TargetProject)')" />

	<!-- If the user didn't supply a TargetName then use the ProjectName -->
	<Property Name="TargetName" Value="$(ProjectName)" If="'$(TargetName)' == ''"/>
	<Property Name="EditorTargetName" Value="$(ProjectName)Editor" If="'$(EditorTargetName)' == ''"/>
	<Property Name="CookedEditorTargetName" Value="$(ProjectName)CookedEditor" If="'$(CookedEditorTargetName)' == ''"/>

	<!-- If skip test is true, add all target platforms to the "do not test" list -->
	<Do If="$(SkipTest)">
		<Property Name="EditorPlatformsToSkipTests" Value="$(EditorPlatforms)" />
		<Property Name="TargetPlatformsToSkipTests" Value="$(TargetPlatforms)" />
		<Property Name="CookedEditorPlatformsToSkipTests" Value="$(CookedEditorPlatforms)" />
		<Property Name="EditorPlatformsToSkipBootTests" Value="$(EditorPlatformsToSkipTests)" />
		<Property Name="TargetPlatformsToSkipBootTests" Value="$(TargetPlatformsToSkipTests)" />
		<Property Name="CookedEditorPlatformsToSkipBootTests" Value="$(CookedEditorPlatformsToSkipTests)" />
	</Do>

	<!-- If skip packaging is true, add all target platforms to the "do not test" list -->
	<Do If="$(SkipPackage)">
		<Property Name="PlatformsToSkipPackaging" Value="$(EditorPlatforms)+$(TargetPlatforms)" />
	</Do>

	<Do If="$(UseIncrementalAgents)" >
		<Property Name="ExtraToolCompileArguments" Value="$(ExtraToolCompileArguments) -allmodules -nodebuginfo -Strict -WarningsAsErrors"/>
		<Property Name="ExtraEditorCompileArguments" Value="$(ExtraEditorCompileArguments) -allmodules -nodebuginfo -Strict -WarningsAsErrors"/>
		<Property Name="ExtraTargetCompileArguments" Value="$(ExtraTargetCompileArguments) -nodebuginfo -WarningsAsErrors"/>
	</Do>

	<!-- On Epic build machines, we want to:
		1. Write dependency information into the cooked output so that it is suitable for use as a base upon which to cook incrementally.
		2. Cook incrementally if the initial state at the start of the job is not empty/blank.
	-->
	<Do If="$(IsEpicBuildMachine)">
		<Property Name="ExtraCookArguments" Value="$(ExtraCookArguments) -cookincremental"/>
	</Do>
	<Option Name="RetrieveUsingCloudArtifacts" DefaultValue="false" Restrict="true|false" Description="Enable to retrieve cloud artifacts" />
	<Option Name="PublishCloudArtifacts" DefaultValue="$(RetrieveUsingCloudArtifacts)" Description="Enable to publish cloud artifacts" />
	<Option Name="PublishHordeArtifacts" DefaultValue="$(IsEpicBuildMachine)" Description="Enable to publish horde artifacts"/>

	<!-- If running with GPU Reshape, override the local build configuration
	     Enables shader symbols and anything else that aids troubleshooting -->
	<Do If="$(DoGPUReshape)">
		<Property Name="ExtraCookArguments" Value="$(ExtraCookArguments) -cvarsini=$(RootDir)\Engine\Source\Programs\GPUReshape\Resources\BuildConfig.ini"/>
	</Do>

	<!-- Detect the type of the client based on the target name -->
	<Property Name="TargetType" Value="Game" />
	<Property Name="TargetType" Value="Client" If="Contains('$(TargetName)', 'Client')" />

	<!-- Sanitize node title for test name that include ':' ie: 'Runtest=Group:Animation' => 'Runtest=Group_Animation' -->
	<Macro Name="SanitizeTestNameTitle">
		<!-- Expect a Property named "TestNameTitle" to be defined beforehand -->
		<Do If="Contains('$(TestNameTitle)', ':')">
			<StringOp Input="$(TestNameTitle)" Method="Replace" Arguments=":;_" Output="TestNameTitle"/>
		</Do>
		<!-- We want to use a user-provided name if any. Expected format of the node name is 'FooTest(arg1+arg2+arg3)[Test Name]' and we want to use Test Name if provided -->
		<!-- This is intentionally after the previous test to override it. -->
		<Do If="Contains('$(TestNameTitle)', '[')">
			<Property Name="HumanReadableName" Value=""/>
			<Regex Pattern="\[(.*)\]" Capture="HumanReadableName" Input="$(TestNameTitle)"/>
			<Property Name="TestNameTitle" Value="$(HumanReadableName)"/>
		</Do>
	</Macro>
	
	<!-- Split TestName from Foo.Test{Arg1 Arg2 Arg3} into Foo.Test and Arg1 Arg2 Arg3 -->
	<Macro Name="SplitCombinedTestNameAndArgs">
		<!-- Expect properties named "TestNameBeforeParentheses" and "TestArgumentsWithinParentheses" to be defined beforehand -->
		<Do If="Contains('$(TestNameBeforeParentheses)', '{')">
			<Property Name="Command" Value=""/>
			<Property Name="Args" Value=""/>
			<Regex Pattern="(.*)\{(.*)\}" Capture="Command;Args" Input="$(TestNameBeforeParentheses)"/>
			<Property Name="TestNameBeforeParentheses" Value="$(Command)"/>
			<Property Name="TestArgumentsWithinParentheses" Value="$(Args)"/>
		</Do>
	</Macro>
	
	<!-- Artifact metadata file -->
	<Macro Name="WriteArtifactMetadataFile" Arguments="Type;Platform;Configuration;ArtifactDir">
		<WriteTextFile Text="{&quot;type&quot;:&quot;$(Type)&quot;,&quot;branch&quot;:&quot;$(Branch)&quot;,&quot;platform&quot;:&quot;$(Platform)&quot;,&quot;change&quot;:&quot;$(Change)&quot;,&quot;preflight&quot;:&quot;$(PreflightChange)&quot;,&quot;buildName&quot;:&quot;$(BuildNamePath)&quot;,&quot;configuration&quot;:&quot;$(Configuration)&quot;}" File="$(ArtifactDir)/artifactmetadata.json" />
	</Macro>

	<!-- These properties will be filled in with nodes that are generated based on options -->
	<Property Name="GeneratedToolNodes" Value="" />
	<Property Name="GeneratedEditorTestNodes" Value="" />
	<Property Name="GeneratedTargetNodes" Value="" />
	<Property Name="GeneratedTargetTestNodes" Value="" />
	<Property Name="GeneratedCookedEditorNodes" Value="" />
	<Property Name="GeneratedCookedEditorTestNodes" Value="" />

	<!-- Do all editor steps under a single agent as the things that can be done in parallel probably aren't worth the overhead-->
	<ForEach Name="EditorPlatform" Values="$(RequiredEditorPlatforms)" Separator="+">
		<!-- Set Agent Types -->
		<Property Name="HostAgentType" Value="$(EditorPlatform)" />
		<!-- Use incremental agents for building? -->
		<Property Name="HostAgentType" Value="Incremental$(HostAgentType)" If="$(UseIncrementalAgents)" />
		<Property Name="TestAgentType" Value="Test$(EditorPlatform)" />
		<Property Name="TestAgentType" Value="$(EditorPlatform)" If="$(DontUseTestAgent)" />
		<!-- Use overrides for agent types? -->
		<Property Name="HostAgentType" Value="$(AgentOverride)" If="'$(AgentOverride)' != ''" />
		<Property Name="TestAgentType" Value="$(TestAgentOverride)"  If="'$(TestAgentOverride)' != ''" />

		<!-- Test nodes for this editor platform -->
		<Property Name="PlatformEditorTestNodes" Value="" />

		<Agent Name="Build $(ProjectName)Editor $(EditorPlatform)" Type="$(HostAgentType)">
			<!-- Update the Version.h and Build.version files if we're making a formal build on a build machine -->
			<Node Name="$(PreNodeName)Update Version Files $(EditorPlatform)">
				<SetVersion Change="$(Change)" Branch="$(EscapedBranch)" If="$(Versioned) and $(IsBuildMachine)"/>
			</Node>
			<!-- First generate nodes to build the required tools (e.g. UHT, ShaderCompiler, Editor -->
			<Node Name="$(PreNodeName)Compile Tools $(EditorPlatform)" Requires="$(PreNodeName)Update Version Files $(EditorPlatform)">
				<Compile Target="ShaderCompileWorker" Platform="$(EditorPlatform)" Configuration="Development" Arguments="$(GenericCompileArguments)"/>
				<Compile Target="ZenLaunch" Platform="$(EditorPlatform)" Configuration="Development" Arguments="$(GenericCompileArguments)"/>
				<Compile Target="GPUReshapeBootstrapper" Platform="$(EditorPlatform)" Configuration="Development" Arguments="$(GenericCompileArguments)" If="$(DoGPUReshape)"/>
				<Compile Target="UnrealPak" Platform="$(EditorPlatform)" Configuration="Development" Arguments="$(GenericCompileArguments)"/>
				<Compile Target="CrashReportClient" Platform="$(EditorPlatform)" Configuration="Shipping" Arguments="$(GenericCompileArguments)"/>
				<Compile Target="CrashReportClientEditor" Platform="$(EditorPlatform)" Configuration="Shipping" Arguments="$(GenericCompileArguments)"/>
				<Do If="$(WithRemoteExecWorkers)" >
					<Compile Target="BaseTextureBuildWorker" Platform="$(EditorPlatform)" Configuration="Development" Arguments="-project=&quot;$(RootDir)/$(TargetProject)&quot; $(GenericCompileArguments)"/>
					<Do If="'$(EditorPlatform)' == 'Win64'" >
						<ForEach Name="TargetPlatform" Values="$(AllConsolePlatforms)" Separator="+">
							<Compile Target="$(TargetPlatform)TextureBuildWorker" Platform="$(EditorPlatform)" Configuration="Development" Arguments="-project=&quot;$(RootDir)/$(TargetProject)&quot; $(GenericCompileArguments)" If="ContainsItem('$(TargetPlatforms)', '$(TargetPlatform)', '+')"/>
						</ForEach>
					</Do>
				</Do>
				<Do If="$(WithInterchangeWorker)" >
					<Compile Target="InterchangeWorker" Platform="$(EditorPlatform)" Configuration="Development" Arguments="$(GenericCompileArguments)"/>
				</Do>
				<Compile Target="UnrealInsights" Platform="$(EditorPlatform)" Configuration="$(UnrealInsightsBuildConfiguration)" Arguments="$(GenericCompileArguments)" If="$(IncludeUnrealInsightsInToolCompile)"/>
				<Compile Target="EpicWebHelper" Platform="$(EditorPlatform)" Configuration="Shipping" Arguments="$(GenericCompileArguments)" If="$(IncludeEpicWebHelperInToolCompile)"/>
			</Node>
			<Property Name="CompileEditor" Value="$(PreNodeName)Compile Editor $(EditorPlatform)"/>
			<Node Name="$(CompileEditor)" Requires="$(PreNodeName)Compile Tools $(EditorPlatform)">
				<Switch>
					<Case If="$(IsContentOnlyProject)">
						<Command Name="BuildCookRun" Arguments="-project=&quot;$(RootDir)/$(TargetProject)&quot; -platform=$(EditorPlatform) -configuration=Development -build -notools -ubtargs=&quot;$(GenericCompileArguments) $(ExtraEditorCompileArguments)&quot;"/>
						<Tag Files="Engine/Binaries/...;$(ProjectPath)/Binaries/..." Filter="UnrealEditor.target;$(EditorTargetName).target" With="#$(CompileEditor)"/>
						<TagReceipt Files="#$(CompileEditor)" BuildProducts="true" With="#$(CompileEditor)"/>
					</Case>
					<Default>
						<Compile Target="$(EditorTargetName)" Platform="$(EditorPlatform)" Configuration="Development" Arguments="$(GenericCompileArguments) $(ExtraEditorCompileArguments)"/>
					</Default>
				</Switch>
			</Node>
			<!-- Cooked editor target -->
			<Node Name="$(PreNodeName)Compile CookedEditor $(EditorPlatform)" Requires="$(PreNodeName)Compile Tools $(EditorPlatform)">
				<ForEach Name="Config" Values="$(CookedEditorConfigurations)" Separator="+">
					<Compile Target="$(CookedEditorTargetName)" Platform="$(EditorPlatform)" Configuration="$(Config)" Arguments="$(GenericCompileArguments) $(ExtraEditorCompileArguments)"/>
				</ForEach>
			</Node>
			<!--Add these nodes to our dependency list -->
			<Property Name="GeneratedToolNodes" Value="$(CompileEditor);$(PreNodeName)Compile Tools $(EditorPlatform)" If="!$(SkipBuild)" />
			<!-- Editor Labels -->
			<Label Category="Editors" Name="$(PreLabelName)Editor $(EditorPlatform)" Requires="$(GeneratedToolNodes)" />
		</Agent>
		<Agent Name="Test $(ProjectName)Editor $(EditorPlatform)" Type="$(TestAgentType)">
			<!-- Prerequisites for the editor test to run -->
			<Property Name="TestPrerequisites" Value="$(GeneratedToolNodes)"/>
			<!-- Declare a boot test for the editor-->
			<Property Name="PlatformBootTestNodeName" Value="$(PreNodeName)Editor $(EditorPlatform) Test=BootTest" />
			<Do If="'$(AutomationReportOutputDirectory)' != ''">
				<Property Name="OutputFragmentPath" Value="$(EditorPlatform)Editor/UE.EditorBootTest" />
				<Property Name="OutputReportPath" Value="$(AutomationReportOutputDirectory)/$(OutputFragmentPath)" />
				<Property Name="GauntletReportArgs" Value="-logdir=&quot;$(OutputReportPath)&quot; -artifactname=Gauntlet -ReportExportPath=&quot;$(OutputReportPath)&quot;" />
				<Property Name="GauntletReportArgs" Value="$(GauntletReportArgs) -ReportURL=&quot;$(AutomationReportUrl)/$(OutputFragmentPath)/&quot;" If="'$(AutomationReportUrl)' != ''" />
			</Do>
			<!-- Annotations -->
			<Property Name="NodeAnnotations" Value=""/>
			<Property Name="NodeAnnotations" Value="Workflow=$(AnnotationsTarget)" If="ContainsItem('$(AnnotationsPlatforms)', '$(EditorPlatform)Editor', ';') and ContainsItem('$(AnnotationsTests)', 'BootTest', ';')"/>
			<Node Name="$(PlatformBootTestNodeName)" Requires="$(TestPrerequisites)" Annotations="$(NodeAnnotations)">
				<Command Name="RunUnreal" Arguments="-project=$(TargetProject) -build=Editor -test=&quot;UE.EditorBootTest&quot; $(GauntletEditorTestArgs) $(GauntletReportArgs)" />
			</Node>
			<Property Name="ProjectEditorDDC" Value="$(PreNodeName)Editor DDC $(EditorPlatform)" />
			<Node Name="$(ProjectEditorDDC)" Requires="$(GeneratedToolNodes)">
				<Property Name="DDCTargetPlatform" Value="$(EditorPlatform)" />
				<Property Name="DDCTargetPlatform" Value="Windows" If="'$(DDCTargetPlatform)' == 'Win64'"/>
				<Commandlet Name="DerivedDataCache" Project="$(RootDir)/$(TargetProject)" Arguments="-fill -targetplatform=$(DDCTargetPlatform)Editor"/>
			</Node>
			<!-- Link the boot test in to the prerequisites and generated nodes if its enabled-->
			<Do If="$(EditorBootTest)">
				<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(PlatformBootTestNodeName)" />
			</Do>
			<!-- Now generate a test node for each editor test in the list-->
			<ForEach Name="TestName" Values="$(EditorTestList)" Separator="+">
				<Property Name="TestNameTitle" Value="$(TestName)"/>
				<Expand Name="SanitizeTestNameTitle"/>
				<Do If="'$(AutomationReportOutputDirectory)' != ''">
					<Property Name="OutputFragmentPath" Value="$(EditorPlatform)/Editor$(TestNameTitle)" />
					<Property Name="OutputReportPath" Value="$(AutomationReportOutputDirectory)/$(OutputFragmentPath)" />
					<Property Name="GauntletReportArgs" Value="-logdir=&quot;$(OutputReportPath)&quot; -artifactname=Gauntlet -ReportExportPath=&quot;$(OutputReportPath)&quot;" />
					<Property Name="GauntletReportArgs" Value="$(GauntletReportArgs) -ReportURL=&quot;$(AutomationReportUrl)/$(OutputFragmentPath)/&quot;" If="'$(AutomationReportUrl)' != ''" />
				</Do>
				<Property Name="TestNodeName" Value="$(PreNodeName)Editor $(EditorPlatform) Test=$(TestNameTitle)" />
				<Property Name="NodeAnnotations" Value=""/>
				<Property Name="NodeAnnotations" Value="Workflow=$(AnnotationsTarget)" If="ContainsItem('$(AnnotationsPlatforms)', '$(EditorPlatform)Editor', ';') and ContainsItem('$(AnnotationsTests)', '$(TestName)', ';')"/>
				<Property Name="TestNameBeforeParentheses" Value="$(TestName)"/>
				<Property Name="TestArgumentsWithinParentheses" Value=""/>
				<Expand Name="SplitCombinedTestNameAndArgs"/>
				<Node Name="$(TestNodeName)" Requires="$(TestPrerequisites)" Annotations="$(NodeAnnotations)">
					<Command Name="RunUnreal" Arguments="-project=$(TargetProject) -build=Editor -test=&quot;$(TestNameBeforeParentheses)&quot; $(GauntletReportArgs) $(GauntletEditorTestArgs) $(TestArgumentsWithinParentheses)" />
				</Node>
				<!-- Add each test node to our generated list -->
				<Property Name="PlatformEditorTestNodes" Value="$(PlatformEditorTestNodes);$(TestNodeName)" />
			</ForEach>
			
			<!-- Expand Post Editor Tests step -->
			<Expand Name="PostEditorTestsStep"/>

			<!-- Create Labels -->
			<Label Category="Editors" Name="$(PreLabelName)Editor DDC $(EditorPlatform)" Requires="$(ProjectEditorDDC)" />

			<!-- If this editor was requested (as opposed to being required due to target platforms) then link in the test nodes and set up labels -->
			<Do If="ContainsItem('$(EditorPlatforms)', '$(EditorPlatform)', '+') and !ContainsItem('$(EditorPlatformsToSkipTests)', '$(EditorPlatform)', '+')">
				<Label Category="Tests" Name="$(PreLabelName)BootTest Editor $(EditorPlatform)" Requires="$(PlatformBootTestNodeName)" />
				<Label Category="Tests" Name="$(PreLabelName)Test Editor $(EditorPlatform)" Requires="$(PlatformEditorTestNodes)" />
				<Property Name="GeneratedEditorTestNodes" Value="$(GeneratedEditorTestNodes);$(PlatformBootTestNodeName)" If="$(EditorBootTest)" />
				<Property Name="GeneratedEditorTestNodes" Value="$(GeneratedEditorTestNodes);$(ProjectEditorDDC)" If="$(FillEditorDDC)" />
				<Property Name="GeneratedEditorTestNodes" Value="$(GeneratedEditorTestNodes);$(PlatformEditorTestNodes)" />
			</Do>
		</Agent>
	</ForEach>

	<!-- Cooked editor Targets -->
	<ForEach Name="EditorPlatform" Values="$(CookedEditorPlatforms)" Separator="+">
		<Property Name="HostAgentType" Value="$(EditorPlatform)" />
		<Property Name="TestAgentType" Value="Test$(EditorPlatform)" />
		<Property Name="TestAgentType" Value="$(EditorPlatform)" If="$(DontUseTestAgent)" />
		<Property Name="TestAgentType" Value="$(TestAgentOverride)" If="'$(TestAgentOverride)' != ''"/>

		<Property Name="EditorPlatformPath" Value="$(EditorPlatform)" />
		<Property Name="EditorPlatformPath" Value="Windows" If="'$(EditorPlatform)' == 'Win64'" />

		<Property Name="PlatformPublishNodeName" Value="$(PreNodeName)Publish CookedEditor $(EditorPlatform)" />

		<Property Name="CookedEditorCookRequirements" Value="$(PreNodeName)Compile Tools $(EditorPlatform);$(PreNodeName)Compile Editor $(EditorPlatform);$(PreNodeName)Compile CookedEditor $(EditorPlatform)"/>
		<Property Name="CookedEditorCookerArgs" Value="-project=$(TargetProject) -platform=$(EditorPlatform) -compressed $(ExtraCookArguments)"/>

		<Agent Name="CookedEditor Cook and Publish $(EditorPlatform)" Type="$(HostAgentType)">
			<!-- Cook Editor -->
			<Node Name="$(PreNodeName)Cook CookedEditor $(EditorPlatform)" Requires="$(CookedEditorCookRequirements)">
				<Command Name="MakeCookedEditor" Arguments="-cook $(CookedEditorCookerArgs)"/>
			</Node>

			<!-- Stage CookedEditor -->
			<Property Name="CookedEditorStageArgs" Value="-skipcook -stage -pak -platform=$(EditorPlatform) -clientconfig=$(CookedEditorConfigurations) -StagingDirectory=&quot;$(ProjectOutputDirectory)&quot;" />
			<Property Name="CookedEditorStageRequirements" Value="$(CookedEditorCookRequirements)"/>
			<Property Name="CookedEditorStageRequirements" Value="$(CookedEditorStageRequirements);$(PreNodeName)Cook CookedEditor $(EditorPlatform)" If="!$(SkipCook)"/>

			<Node Name="$(PreNodeName)Stage CookedEditor $(EditorPlatform)" Requires="$(CookedEditorStageRequirements)">	
				<Command Name="MakeCookedEditor" Arguments="-project=$(TargetProject) $(CookedEditorStageArgs)"/>
			</Node>

			<!-- Publish CookedEditor -->
			<Node Name="$(PlatformPublishNodeName)" Requires="$(PreNodeName)Stage CookedEditor $(EditorPlatform)">
				<Property Name="TargetDirectory" Value="$(ProjectOutputDirectory)/$(EditorPlatformPath)CookedEditor"/>
				<Do If="$(UseNetworkShare)">
					<Log Message="Copying to $(NetworkOutputDirectory)/$(EditorPlatformPath)CookedEditor"/>
					<Do If="!$(SkipPublish)">
						<Copy Files="..." From="$(TargetDirectory)" To="$(NetworkOutputDirectory)/$(EditorPlatformPath)CookedEditor"/>
					</Do>
				</Do>
				<Expand Name="WriteArtifactMetadataFile" Type="staged-build" Platform="$(EditorPlatform)" Configuration="Development" ArtifactDir="$(TargetDirectory)" />
				<Tag Files="$(TargetDirectory)/..." With="#Staged CookedEditor Files"/>
				<Do If="$(PublishHordeArtifacts)">
					<CreateArtifact Name="$(ProjectName)-Staged-Cooked-Editor-$(EditorPlatform)" Type="staged-build" BaseDir="$(TargetDirectory)" Keys="Project=$(ProjectName)" Metadata="Stream=$(Branch);Platform=$(EditorPlatform);Configuration=Development;BuildName=$(BuildNamePath);dashboard-category=Development Builds" Files="#Staged CookedEditor Files"/>
				</Do>
				<Do If="$(PublishCloudArtifacts)">
					<CreateCloudArtifact Name="$(BuildNamePath)-Staged-Cooked-Editor" HordeArtifactName="Cloud-$(ProjectName)-Staged-Cooked-Editor-$(EditorPlatform)" Type="staged-build" BaseDir="$(TargetDirectory)" Metadata="Configuration=Development;dashboard-category=Staged Builds - Cloud" Project="$(TargetProject)" Platform="$(EditorPlatform)" Files="#Staged CookedEditor Files"/>
				</Do>
				<Delete Files="$(TargetDirectory)/artifactmetadata.json"/>
			</Node>

			<!-- Aggregate Nodes requirements -->
			<Property Name="GeneratedCookedEditorNodes" Value="$(PreNodeName)Compile CookedEditor $(EditorPlatform)" If="!$(SkipBuild)" />
			<Property Name="GeneratedCookedEditorNodes" Value="$(GeneratedCookedEditorNodes);$(PreNodeName)Cook CookedEditor $(EditorPlatform)" If="!$(SkipCook)" />
			<Property Name="GeneratedCookedEditorNodes" Value="$(GeneratedCookedEditorNodes);$(PlatformPublishNodeName)" If="!$(SkipPublish) And ($(PublishBuilds) Or $(PublishHordeArtifacts) Or $(PublishCloudArtifacts))" />
		</Agent>

		<!-- Tests -->
		<Agent Name="Test $(ProjectName)CookedEditor $(EditorPlatform)" Type="$(TestAgentType)">
			<Property Name="CustomModuleRoleArg" Value="-CustomModuleRoles=$(CookedEditorTargetName):CookedEditor"/>
			<Property Name="CookedEditorBuildPath" Value="$(NetworkOutputDirectory)/$(EditorPlatformPath)CookedEditor" />
			<!-- Prerequisites for the editor test to run -->
			<Property Name="TestPrerequisites" Value="$(GeneratedCookedEditorNodes)"/>
			<Do If="$(PublishHordeArtifacts) And !$(RetrieveUsingCloudArtifacts)">
				<Property Name="HordeArtifactPlatformRetrieve" Value="$(PreNodeName)Retrieve CookedEditor Build Artifact $(EditorPlatform) (Horde)"/>
				<Node Name="$(HordeArtifactPlatformRetrieve)" Requires="$(TestPrerequisites);$(PlatformPublishNodeName)">
					<RetrieveArtifact Name="$(ProjectName)-Staged-Cooked-Editor-$(EditorPlatform)" Type="staged-build" OutputDir="$(ProjectOutputDirectory)/$(EditorPlatformPath)CookedEditor" />
				</Node>
				<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(HordeArtifactPlatformRetrieve)" />
				<Property Name="CookedEditorBuildPath" Value="$(ProjectOutputDirectory)/$(EditorPlatformPath)CookedEditor" />
			</Do>
			<Do If="$(RetrieveUsingCloudArtifacts)">
				<Property Name="CloudArtifactPlatformRetrieve" Value="$(PreNodeName)Retrieve CookedEditor Build Artifact $(EditorPlatform) (Cloud)"/>
				<Node Name="$(CloudArtifactPlatformRetrieve)" Requires="$(TestPrerequisites);$(PlatformPublishNodeName)">
					<RetrieveCloudArtifact Name="$(BuildNamePath)-Staged-Cooked-Editor" Type="staged-build" OutputDir="$(ProjectOutputDirectory)/$(EditorPlatformPath)CookedEditor" Project="$(TargetProject)" Platform="$(EditorPlatform)" />
				</Node>
				<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(CloudArtifactPlatformRetrieve)" />
				<Property Name="CookedEditorBuildPath" Value="$(ProjectOutputDirectory)/$(EditorPlatformPath)CookedEditor" />
			</Do>
			<!-- Declare a boot test for the editor-->
			<Property Name="PlatformBootTestNodeName" Value="$(PreNodeName)CookedEditor $(EditorPlatform) Test=BootTest" />
			<Do If="'$(AutomationReportOutputDirectory)' != ''">
				<Property Name="OutputFragmentPath" Value="$(EditorPlatform)Editor/UE.CookedEditorBootTest" />
				<Property Name="OutputReportPath" Value="$(AutomationReportOutputDirectory)/$(OutputFragmentPath)" />
				<Property Name="GauntletReportArgs" Value="-logdir=&quot;$(OutputReportPath)&quot; -artifactname=Gauntlet -ReportExportPath=&quot;$(OutputReportPath)&quot;" />
				<Property Name="GauntletReportArgs" Value="$(GauntletReportArgs) -ReportURL=&quot;$(AutomationReportUrl)/$(OutputFragmentPath)/&quot;" If="'$(AutomationReportUrl)' != ''" />
			</Do>
			<Property Name="NodeAnnotations" Value=""/>
			<Property Name="NodeAnnotations" Value="Workflow=$(AnnotationsTarget)" If="ContainsItem('$(AnnotationsPlatforms)', '$(EditorPlatform)Editor', ';') and ContainsItem('$(AnnotationsTests)', 'BootTest', ';')"/>
			<Node Name="$(PlatformBootTestNodeName)" Requires="$(TestPrerequisites)" Annotations="$(NodeAnnotations)">
				<Command Name="RunUnreal" Arguments="-project=$(TargetProject) -build=&quot;$(CookedEditorBuildPath)&quot; -test=&quot;UE.EditorBootTest&quot; $(GauntletCookedEditorTestArgs) $(CustomModuleRoleArg) $(GauntletReportArgs)" />
			</Node>

			<!-- Link the boot test in to the prerequisites and generated nodes if its enabled-->
			<Do If="$(CookedEditorBootTest)">
				<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(PlatformBootTestNodeName)" />
			</Do>
			<!-- Now generate a test node for each editor test in the list-->
			<Property Name="PlatformCookedEditorTestNodes" Value="" />
			<ForEach Name="TestName" Values="$(CookedEditorTestList)" Separator="+">
				<Property Name="TestNameTitle" Value="$(TestName)"/>
				<Expand Name="SanitizeTestNameTitle"/>
				<Do If="'$(AutomationReportOutputDirectory)' != ''">
					<Property Name="OutputFragmentPath" Value="$(EditorPlatform)/Editor$(TestNameTitle)" />
					<Property Name="OutputReportPath" Value="$(AutomationReportOutputDirectory)/$(OutputFragmentPath)" />
					<Property Name="GauntletReportArgs" Value="-logdir=&quot;$(OutputReportPath)&quot; -artifactname=Gauntlet -ReportExportPath=&quot;$(OutputReportPath)&quot;" />
					<Property Name="GauntletReportArgs" Value="$(GauntletReportArgs) -ReportURL=&quot;$(AutomationReportUrl)/$(OutputFragmentPath)/&quot;" If="'$(AutomationReportUrl)' != ''" />
				</Do>
				<Property Name="TestNodeName" Value="$(PreNodeName)CookedEditor $(EditorPlatform) Test=$(TestNameTitle)" />
				<Property Name="NodeAnnotations" Value=""/>
				<Property Name="NodeAnnotations" Value="Workflow=$(AnnotationsTarget)" If="ContainsItem('$(AnnotationsPlatforms)', '$(EditorPlatform)Editor', ';') and ContainsItem('$(AnnotationsTests)', '$(TestName)', ';')"/>
				<Property Name="TestNameBeforeParentheses" Value="$(TestName)"/>
				<Property Name="TestArgumentsWithinParentheses" Value=""/>
				<Expand Name="SplitCombinedTestNameAndArgs"/>
				<Node Name="$(TestNodeName)" Requires="$(TestPrerequisites)" Annotations="$(NodeAnnotations)">
					<Command Name="RunUnreal" Arguments="-project=$(TargetProject) -build=&quot;$(CookedEditorBuildPath)&quot; -test=&quot;$(TestNameBeforeParentheses)&quot; $(GauntletReportArgs) $(CustomModuleRoleArg) $(GauntletCookedEditorTestArgs) $(TestArgumentsWithinParentheses)" />
				</Node>
				<!-- Add each test node to our generated list -->
				<Property Name="PlatformCookedEditorTestNodes" Value="$(PlatformCookedEditorTestNodes);$(TestNodeName)" />
			</ForEach>

			<!-- Create Labels -->
			<!-- If this cooked editor was requested (as opposed to being required due to target platforms) then link in the test nodes and set up labels -->
			<Do If="ContainsItem('$(CookedEditorPlatforms)', '$(EditorPlatform)', '+') and !ContainsItem('$(CookedEditorPlatformsToSkipTests)', '$(EditorPlatform)', '+')">
				<Label Category="Tests" Name="$(PreLabelName)BootTest CookedEditor $(EditorPlatform)" Requires="$(PlatformBootTestNodeName)" />
				<Label Category="Tests" Name="$(PreLabelName)Test CookedEditor $(EditorPlatform)" Requires="$(PlatformCookedEditorTestNodes)" />
				<Property Name="GeneratedCookedEditorTestNodes" Value="$(GeneratedCookedEditorTestNodes);$(PlatformBootTestNodeName)" If="$(CookedEditorBootTest)" />
				<Property Name="GeneratedCookedEditorTestNodes" Value="$(GeneratedCookedEditorTestNodes);$(PlatformCookedEditorTestNodes)" />
			</Do>
		</Agent>

		<!-- Add to Editor Labels -->
		<Label Category="Editors" Name="$(PreLabelName)CookedEditor $(EditorPlatform)" Requires="$(GeneratedCookedEditorNodes)" />
	</ForEach>

	<!-- Now, for each platform we build, cook, stage, package, publish, and test -->
	<ForEach Name="TargetPlatform" Values="$(TargetPlatforms)" Separator="+">

		<Property Name="IsDesktopPlatform" Value="ContainsItem('$(AllDesktopPlatforms)', '$(TargetPlatform)', '+')"/>
		<Property Name="IsMobilePlatform" Value="('$(TargetPlatform)' == 'Android' or '$(TargetPlatform)' == 'IOS')"/>
		<!-- Local or virtualized platform -->
		<Property Name="IsVirtualizedPlatform" Value="ContainsItem('$(AllVirtualizedPlatforms)', '$(TargetPlatform)', '+')"/>
		<Property Name="IsLocalPlatform" Value="($(IsDesktopPlatform) Or $(IsVirtualizedPlatform))"/>

		<Property Name="IsTargetPlatformMac" Value="('$(TargetPlatform)' == 'Mac' or '$(TargetPlatform)' == 'IOS' or '$(TargetPlatform)' == 'tvOS')"/>
		<Property Name="IsTargetPlatformLinux" Value="('$(TargetPlatform)' == 'Linux')"/>
		<Property Name="IsTargetPlatformWindows" Value="(!$(IsTargetPlatformMac) and !$(IsTargetPlatformLinux))"/>
		
		<!-- Declare type of host required to build & cook this platform-->
		<Property Name="HostAgentType" Value="$(EditorPlatformWin64AgentOverride)" /> 
		<Property Name="HostAgentType" Value="$(EditorPlatformMacAgentOverride)" If="$(IsTargetPlatformMac)"/>
		<Property Name="HostAgentType" Value="$(EditorPlatformLinuxAgentOverride)" If="$(IsTargetPlatformLinux)"/>

		<Property Name="IsEditorAgentOverride" Value="false"/>
		<Property Name="IsEditorAgentOverride" Value="true" If="$(IsTargetPlatformWindows) and '$(EditorPlatformWin64AgentOverride)'!='Win64'"/>
		<Property Name="IsEditorAgentOverride" Value="true" If="$(IsTargetPlatformMac) and '$(EditorPlatformMacAgentOverride)'!='Mac'"/>
		<Property Name="IsEditorAgentOverride" Value="true" If="$(IsTargetPlatformLinux) and '$(EditorPlatformLinuxAgentOverride)'!='Linux'"/>
		<!-- On consoles we can use agents with devkit setup, but locally hosted tests need a Test agent-->
		<Property Name="TestAgentType" Value="$(TargetPlatformTestAgentOverride)" />
		<Property Name="TestAgentType" Value="Test$(HostAgentType)" If="$(IsDesktopPlatform)"/>
		<Property Name="TestAgentType" Value="$(HostAgentType)" If="$(IsDesktopPlatform) and $(DontUseTestAgent)" />

		<!-- Use incremental agents for building? -->
		<Property Name="CompileAgentType" Value="$(HostAgentType)" />
		<Property Name="CompileAgentType" Value="Incremental$(HostAgentType)" If="$(UseIncrementalAgents)" />

		<!-- Use agent types from override? -->
		<Property Name="CompileAgentType" Value="$(AgentOverride)" If="'$(AgentOverride)' != ''"/>
		<!-- Use the same agent type for packaging as compilation -->
		<Property Name="PackageAgentType" Value="$(CompileAgentType)"/>
		<Property Name="CompileAgentType" Value="$(ClientCompileAgentOverride)" If="'$(ClientCompileAgentOverride)' != ''"/>
		<Property Name="TestAgentType" Value="$(TestAgentOverride)" If="'$(TestAgentOverride)' != ''"/>

		<Property Name="PreNodeNameWithPlatform" Value="$(PreNodeName)"/>
		<Property Name="PreNodeNameWithPlatform" Value="[$(HostAgentType)]$(PreNodeName)" If="$(IsEditorAgentOverride)"/>
		<!-- Building and cooking will require these nodes from the appropriate host. They should have been built above... -->
		<Property Name="PlatformToolsNodeName" Value="$(PreNodeName)Compile Tools $(HostAgentType)" />
		<Property Name="PlatformEditorNodeName" Value="$(PreNodeName)Compile Editor $(HostAgentType)" />
		<!-- Define these names up front as we use some of them several times -->
		<Property Name="PlatformAgentName" Value="$(ProjectName) $(TargetPlatform)" />
		<Property Name="PlatformCompileNodeName" Value="$(PreNodeNameWithPlatform)Compile $(TargetPlatform)" />
		<Property Name="UploadSymbolsNodeName" Value="" />
		<Property Name="UploadSymbolsNodeName" Value="$(PreNodeNameWithPlatform)Upload Symbols $(TargetPlatform)" If="'$(SymbolServerPath)' != '' And !$(IsMobilePlatform)" />
		<Property Name="PlatformCookNodeName" Value="$(PreNodeNameWithPlatform)Cook $(TargetPlatform)" />
		<Property Name="PlatformStageNodeName" Value="$(PreNodeNameWithPlatform)Stage $(TargetPlatform)" />
		<Property Name="PlatformPackageNodeName" Value="$(PreNodeNameWithPlatform)Package $(TargetPlatform)" />
		<Property Name="PlatformPackageArtifactName" Value="$(PlatformPackageNodeName)" />
		<Property Name="PlatformHashNodeName" Value="$(PreNodeNameWithPlatform)Hash $(TargetPlatform)" />
		<Property Name="PlatformPublishStagedNodeName" Value="$(PreNodeNameWithPlatform)Publish Staged $(TargetPlatform)" />
		<Property Name="PlatformPublishPackagedNodeName" Value="$(PreNodeNameWithPlatform)Publish Packaged $(TargetPlatform)" />
		<Property Name="PlatformCheckBuildSizeNodeName" Value="$(PreNodeNameWithPlatform)Check Build Size $(TargetPlatform)" />
		<Property Name="PlatformStagedArtifactNodeName" Value="$(PlatformPublishStagedNodeName) (Horde)" />
		<Property Name="CloudPlatformStagedArtifactNodeName" Value="$(PlatformPublishStagedNodeName) (Cloud)" />
		<Property Name="HordeArtifactPlatformPackagedNodeName" Value="$(PlatformPublishPackagedNodeName) (Horde)" />
		<Property Name="HordeArtifactPlatformRetrieve" Value="$(PreNodeNameWithPlatform)Retrieve Build Artifact $(TargetPlatform)" />
		<Property Name="CloudArtifactPlatformPackagedNodeName" Value="$(PlatformPublishPackagedNodeName) (Cloud)" />
		<Property Name="CloudArtifactPlatformRetrieve" Value="$(PreNodeNameWithPlatform)Retrieve Build Artifact $(TargetPlatform)" />
		<Property Name="RequirePlatformStaged" Value="$(PlatformStageNodeName)" />
		<Property Name="RequirePlatformStaged" Value="$(RequirePlatformStaged);$(PlatformStagedArtifactNodeName)" If="!$(SkipPublish) And $(PublishHordeArtifacts)"/>
		<Property Name="RequirePlatformStaged" Value="$(RequirePlatformStaged);$(CloudPlatformStagedArtifactNodeName)" If="!$(SkipPublish) And $(PublishCloudArtifacts)"/>
		<Property Name="RequirePlatformStaged" Value="$(RequirePlatformStaged);$(PlatformPublishStagedNodeName)" If="!$(SkipPublish) And $(PublishBuilds)"/>
		<Property Name="RequirePlatformPackaged" Value="$(PlatformPackageNodeName)" />
		<Property Name="RequirePlatformPackaged" Value="$(RequirePlatformPackaged);$(HordeArtifactPlatformPackagedNodeName)" If="!$(SkipPublish) And $(PublishHordeArtifacts)"/>
		<Property Name="RequirePlatformPackaged" Value="$(RequirePlatformPackaged);$(CloudArtifactPlatformPackagedNodeName)" If="!$(SkipPublish) And $(PublishCloudArtifacts)"/>
		<Property Name="RequirePlatformPackaged" Value="$(RequirePlatformPackaged);$(PlatformPublishPackagedNodeName)"  If="!$(SkipPublish) And $(PublishBuilds)"/>
		
		<!-- Set CookPlatform since it isn't always the same as the target -->
		<Property Name="CookPlatform" Value="$(TargetPlatform)" />
		<Property Name="CookPlatform" Value="Windows" If="'$(TargetPlatform)' == 'Win64'"/>
		<Property Name="CookPlatform" Value="$(CookPlatform)_$(AndroidCookFlavor)" If="'$(TargetPlatform)' == 'Android'"/>
		<Property Name="CookPlatform" Value="$(CookPlatform)Client" If="'$(TargetType)' == 'Client'" />

		<!-- Only use Cook Flavor for Android -->
		<Property Name="BCRCookFlavor" Value=""/>
        <Property Name="BCRCookFlavor" Value="$(AndroidCookFlavor)" If="'$(TargetPlatform)' == 'Android'" />
		
		<Property Name="StagedPlatformFolder" Value="$(CookPlatform)"  />
		<!-- <Property Name="StagedPlatformFolder" Value="$(StagedPlatformFolder)Client" If="'$(TargetType)' == 'Client'" /> -->

		<!-- Hashing of staged data can only be done on Win64 hosts -->
		<Property Name="DoUnsyncHashing" Value="$(HostAgentType) == 'Win64' and $(IsEpicInternal)" />

		<!-- Default BuildCookRun args needed when staging/packaging/archiving this configuration -->
		<Property Name="BCRArgs" Value="-project=$(TargetProject) -platform=$(TargetPlatform) -cookflavor=&quot;$(BCRCookFlavor)&quot;" />
		<Property Name="BCRArgs" Value="$(BCRArgs) -client" If="'$(TargetType)' == 'Client'" />
		<Property Name="BCRArgs" Value="$(BCRArgs) -server" If="'$(DedicatedServer)'" />

		<!-- Support additional stage and package arguments that are only active on some platforms -->
		<Property Name="StageAndPackageArguments" Value="$(ExtraStageAndPackageArguments)" />
		<Property Name="StageAndPackageArguments" Value="$(StageAndPackageArguments) $(TargetPlatformFilteredExtraStageAndPackageArguments)" If="'$(TargetPlatformFilteredExtraStageAndPackageArgumentsFilter)' != '' and ContainsItem('$(TargetPlatformFilteredExtraStageAndPackageArgumentsFilter)', '$(TargetPlatform)', '+')" />
		<Property Name="PackageOnlyArguments" Value="$(ExtraPackageOnlyArguments)" />

		<Property Name="BuildSizeLimit" Value=""/>
		<Regex Pattern="(?&lt;!\w)$(TargetPlatform):([0-9]+)" Capture="BuildSizeLimit" Input="$(CheckBuildSizePlatforms)"/>

		<!-- Build the client and if necessary a server-->
		<Agent Name="Compile $(PlatformAgentName)" Type="$(CompileAgentType)">

			<!-- Compile -->
			<Node Name="$(PlatformCompileNodeName)" Requires="$(PlatformToolsNodeName)">
				<Switch>
					<Case If="$(IsContentOnlyProject)">
						<Command Name="BuildGame" Arguments="$(BCRArgs) -configuration=$(TargetConfigurations) -notools -ubtargs=&quot;-BuildVersion=$(BuildVersion) $(GenericCompileArguments) $(ExtraTargetCompileArguments)&quot;" />
						<Tag Files="$(ProjectPath)/Binaries/..." Filter="$(TargetName)*.target" With="#$(PlatformCompileNodeName)"/>
						<Tag Files="$(ProjectPath)/Binaries/..." Filter="UnrealGame*.target" With="#UnrealGameTarget"/>
						<Copy Files="#UnrealGameTarget" From="$(ProjectPath)" To="Engine" Tag="#$(PlatformCompileNodeName)"/>
						<TagReceipt Files="#$(PlatformCompileNodeName)" BuildProducts="true" With="#$(PlatformCompileNodeName)"/>
					</Case>
					<Default>
						<ForEach Name="TargetConfiguration" Values="$(TargetConfigurations)" Separator="+">
							<Compile Target="$(TargetName)" Platform="$(TargetPlatform)" Configuration="$(TargetConfiguration)" Arguments="-BuildVersion=&quot;$(BuildVersion)&quot; $(GenericCompileArguments) $(ExtraTargetCompileArguments)"/>
							<Do If="'$(DedicatedServer)'" >
								<Compile Target="$(TargetName)Server" Platform="Win64" Configuration="$(TargetConfiguration)" Arguments="-BuildVersion=&quot;$(BuildVersion)&quot; $(GenericCompileArguments) $(ExtraTargetCompileArguments)"/>
							</Do>
						</ForEach>
					</Default>
				</Switch>
			</Node>

			<!-- (Optional) Upload Symbols -->
			<Do If="'$(UploadSymbolsNodeName)' != ''">
				<Node Name="$(UploadSymbolsNodeName)" Requires="$(PlatformCompileNodeName)">
					<Log Message="Uploading symbols to &quot;$(SymbolServerPath)&quot; ..."/>
					<SymStore Platform="$(TargetPlatform)" Files="#$(PlatformCompileNodeName)" StoreDir="$(SymbolServerPath)/$(TargetPlatform)" Product="$(TargetName)" BuildVersion="$(BuildVersion)" />
				</Node>
			</Do>

		</Agent>

		<!-- Separate agent for cooking / staging, so the cook can happen in parallel with the client compile -->
		<Agent Name="Package $(PlatformAgentName)" Type="$(PackageAgentType)">

			<!-- Cook -->
			<Node Name="$(PlatformCookNodeName)" Requires="$(PlatformEditorNodeName)" Produces="#$(PlatformCookNodeName) Complete" RunEarly="true">
				<Do If="!$(SkipCook)">
					<Expand Name="PreCookStep"/>
					<Property Name="CookArgs" Value="" />
					<Property Name="CookArgs" Value="-MapIniSection=&quot;$(MapIniSection)&quot; $(CookPlatform)" If="'$(MapIniSection)' != ''"/>				
					<Cook Project="$(TargetProject)" Platform="$(CookPlatform)" TagOutput="false" Arguments="$(CookArgs) $(ExtraCookArguments)"/>
				</Do>
			</Node>
			
			<!-- Stage -->
			<Node Name="$(PlatformStageNodeName)" Requires="$(PlatformCompileNodeName);#$(PlatformCookNodeName) Complete">
				<Switch>
					<Case If="$(IsMobilePlatform)">
						<ForEach Name="PackageConfiguration" Values="$(PackageConfigurations)" Separator="+">
							<Command Name="BuildCookRun" Arguments="$(BCRArgs) -configuration=$(PackageConfiguration) $(StageAndPackageArguments) -skipbuild -skipcook -stage -pak" />
						</ForEach>
					</Case>
					<Default>
						<Command Name="BuildCookRun" Arguments="$(BCRArgs) -configuration=$(PackageConfigurations) $(StageAndPackageArguments) -skipbuild -skipcook -stage -pak -NoCodeSign" />
					</Default>
				</Switch>
			</Node>
			
			<!-- Hash -->
			<Node Name="$(PlatformHashNodeName)" Requires="$(PlatformStageNodeName)">
				<Do If="$(DoUnsyncHashing)">
					<Spawn Exe="$(RootDir)/Engine/Restricted/NotForLicensees/Binaries/Win64/unsync.exe" Arguments="hash &quot;$(ProjectOutputDirectory)/$(StagedPlatformFolder)&quot; -v --buffered-files"/>
				</Do>
			</Node>

			<!-- (Optional) Publish from local Zen to Cloud or remote Zen server -->
			<Property Name="PlatformPublishStageDependencyName" Value="$(PlatformHashNodeName)" />
			<Property Name="ShouldSnapshotPublishCloud" Value="false"/>
			<Property Name="ShouldSnapshotPublishCloud" Value="true" If="$(PublishCloudSnapshot) and '$(UE-CloudPublishHost)' != ''"/>
			<Property Name="ShouldSnapshotPublishZen" Value="false"/>
			<Property Name="ShouldSnapshotPublishZen" Value="true" If="$(IsBuildMachine) and !$(IsPreflight) and $(PublishZenSnapshot) and '$(UE-ZenPublishHost)' != ''"/>
			<Property Name="ShouldSnapshotPublish" Value="false"/>
			<Property Name="ShouldSnapshotPublish" Value="true" If="$(IsBuildMachine) and !$(IsPreflight) and $(ShouldSnapshotPublishCloud) or $(ShouldSnapshotPublishZen)"/>
			<Do If="$(PublishBuilds) and $(ShouldSnapshotPublish)">
				<Property Name="PlatformSnapshotPublishNodeName" Value="$(PreNodeName)Snapshot Publish $(TargetPlatform)" />
				<Node Name="$(PlatformSnapshotPublishNodeName)" Requires="$(PlatformHashNodeName)">
					<Property Name="SnapshotLocalDir" Value="$(RootDir)/Snapshots" />
					<Property Name="SnapshotIdentifier" Value="$(EscapedBranch)/$(BuildNamePath)"/>
					<Property Name="SnapshotIdentifier" Value="$(UE_HORDE_TEMPLATEID).$(BuildVersion).$(UE_HORDE_JOBID:-6).$(UE_HORDE_STEPID)" If="'$(UE_HORDE_JOBID)' != '' and '$(UE_HORDE_STEPID)' != '' and '$(UE_HORDE_TEMPLATEID)' != ''"/>
					<Property Name="SnapshotFilenamePrefix" Value="SnapshotDescriptor"/>
					<Property Name="SnapshotFilenamePrefix" Value="$(UE_HORDE_TEMPLATEID)" If="'$(UE_HORDE_TEMPLATEID)' != ''"/>
					<Property Name="SnapshotLongTermPlatformFolder" Value="$(StagedPlatformFolder)" />
					<Property Name="SnapshotLongTermPlatformFolder" Value="Android" If="'$(TargetPlatform)' == 'Android'" />
					<Property Name="SnapshotLongTermStorageDir" Value="$(NetworkSnapshotDescFileRoot)/$(EscapedBranch)/$(ProjectName)/$(SnapshotLongTermPlatformFolder)/$(Change)"  If="'$(NetworkSnapshotDescFileRoot)' != ''"/>

					<Do If="$(ShouldSnapshotPublishCloud)">
						<Property Name="SnapshotBranch" Value="$(EscapedBranch)"/>
						<StringOp Input="$(EscapedBranch)" Method="Replace" Arguments=".;-" Output="SnapshotBranch"/>
						<!-- Publish to builds cloud storage endpoint -->
						<Property Name="SnapshotBuildBaselineBranch" Value="$(Branch)"/>
						<Property Name="SnapshotBuildBaselineBranch" Value="$(UE-CloudPublishBaselineBranch)" If="'$(UE-CloudPublishBaselineBranch)' != ''"/>
						<Property Name="SnapshotBuildMetaData" Value="name=$(SnapshotIdentifier);depot=$(Depot);branch=$(Branch);baselineBranch=$(SnapshotBuildBaselineBranch);project=$(ProjectName);runtime=$(TargetType);platform=$(TargetPlatform);cookPlatform=$(CookPlatform);changelist=$(Change);codeChangelist=$(CodeChange);isPreflight=$(IsPreflight);isBuildMachine=$(IsBuildMachine);isHordeEnv=$(IsHordeEnv)"/>
						<Property Name="SnapshotBuildMetaData" Value="$(SnapshotBuildMetaData);cookFlavor=$(BCRCookFlavor)" If="'$(BCRCookFlavor)' != ''" />
						<Property Name="SnapshotBuildMetaData" Value="$(SnapshotBuildMetaData);preflightChangelist=$(PreflightChange)" If="'$(PreflightChange)' != ''" />
						<Property Name="SnapshotBuildMetaData" Value="$(SnapshotBuildMetaData);hordeTemplateId=$(UE_HORDE_TEMPLATEID)" If="'$(UE_HORDE_TEMPLATEID)' != ''" />
						<Log Message="Publishing build with metadata '$(SnapshotBuildMetaData)'"/>
						<ZenExportSnapshot Project="$(TargetProject)" Platform="$(CookPlatform)" DestinationStorageType="Builds" DestinationCloudHost="$(UE-CloudPublishHost)" DestinationCloudHttpVersion="$(UE-CloudPublishHttpVersion)" SnapshotDescriptorCloudHost="$(UE-CloudPublishDescriptorHost)" SnapshotDescriptorCloudHttpVersion="$(UE-CloudPublishDescriptorHttpVersion)" DestinationCloudNamespace="$(UE-CloudPublishNamespace)" DestinationCloudBucket="$(ProjectName).oplog.$(SnapshotBranch).$(CookPlatform)" DestinationIdentifier="$(SnapshotIdentifier)" SnapshotDescriptorFile="$(SnapshotLocalDir)/$(StagedPlatformFolder)/$(SnapshotFilenamePrefix)-builds.json" Metadata="$(SnapshotBuildMetaData)"/>
						<Copy From="$(SnapshotLocalDir)/$(StagedPlatformFolder)/$(SnapshotFilenamePrefix)-builds.json" To="$(NetworkOutputDirectory)/$(StagedPlatformFolder)/SnapshotDescriptor.json"/>
						<Do If="'$(SnapshotLongTermStorageDir)' != ''">
							<Copy From="$(SnapshotLocalDir)/$(StagedPlatformFolder)/$(SnapshotFilenamePrefix)-builds.json" To="$(SnapshotLongTermStorageDir)/$(SnapshotFilenamePrefix)-builds.json"/>
						</Do>
					</Do>
					<Do If="$(ShouldSnapshotPublishZen)">
						<ZenExportSnapshot Project="$(TargetProject)" Platform="$(CookPlatform)" DestinationStorageType="Zen" DestinationZenHost="$(UE-ZenPublishHost)" DestinationIdentifier="$(SnapshotIdentifier)" SnapshotDescriptorFile="$(SnapshotLocalDir)/$(StagedPlatformFolder)/$(SnapshotFilenamePrefix)-zen.json"/>
						<Copy From="$(SnapshotLocalDir)/$(StagedPlatformFolder)/$(SnapshotFilenamePrefix)-zen.json" To="$(NetworkOutputDirectory)/$(StagedPlatformFolder)/SnapshotDescriptorZen.json"/>
						<Do If="'$(SnapshotLongTermStorageDir)' != ''">
							<Copy From="$(SnapshotLocalDir)/$(StagedPlatformFolder)/$(SnapshotFilenamePrefix)-zen.json" To="$(SnapshotLongTermStorageDir)/$(SnapshotFilenamePrefix)-zen.json"/>
						</Do>
					</Do>
					<Tag Files="$(SnapshotLocalDir)/..." With="#SnapshotDescriptor_$(StagedPlatformFolder)"/>

					<CreateArtifact Name="$(ProjectName)-ci-snapshot-$(StagedPlatformFolder)" Description="Snapshot ($(StagedPlatformFolder))" Type="ugs-snapshot" BaseDir="Snapshots" Keys="ugs-project=$(TargetProject)" Metadata="ArchiveType=SnapshotDescriptor_$(StagedPlatformFolder);dashboard-category=Snapshots" Files="#SnapshotDescriptor_$(StagedPlatformFolder)"/>
				</Node>
				<Property Name="PlatformPublishStageDependencyName" Value="$(PlatformSnapshotPublishNodeName)" />
			</Do>
			
			<!-- Publish (Staged) -->
			<Node Name="$(PlatformPublishStagedNodeName)" Requires="$(PlatformPublishStageDependencyName)">
				<Error Message="NetworkOutputDirectory is not set" If="'$(NetworkOutputDirectory)' == ''"/>
				<Copy Files="..." From="$(ProjectOutputDirectory)/$(StagedPlatformFolder)" To="$(NetworkOutputDirectory)/$(StagedPlatformFolder)/Staged"/>
				<Copy Files="..." From="$(ShaderSymbolsDirectory)/*$(TargetPlatform)*" To="$(NetworkOutputDirectory)/$(StagedPlatformFolder)/ShaderSymbols"/>
			</Node>

			<!-- Publish (Staged) (Cloud) -->
			<Do If="$(PublishCloudArtifacts)">
				<Node Name="$(CloudPlatformStagedArtifactNodeName)" Requires="$(PlatformStageNodeName)">
					<Property Name="TargetDirectory" Value="$(ProjectOutputDirectory)/$(StagedPlatformFolder)"/>
					<Expand Name="WriteArtifactMetadataFile" Type="staged-build" Platform="$(StagedPlatformFolder)" Configuration="$(PackageConfigurations)" ArtifactDir="$(TargetDirectory)" />
					<Tag Files="$(TargetDirectory)/..." With="#$(PlatformStageNodeName) Files"/>

					<CreateCloudArtifact Name="$(BuildNamePath)-Staged" HordeArtifactName="Cloud-$(ProjectName)-Staged-$(StagedPlatformFolder)" Type="staged-build" BaseDir="$(TargetDirectory)" Metadata="dashboard-category=Staged Builds - Cloud" Project="$(TargetProject)" Platform="$(StagedPlatformFolder)" Files="#$(PlatformStageNodeName) Files"/>
					<Delete Files="$(TargetDirectory)/artifactmetadata.json"/>
				</Node>
			</Do>

			<!-- Publish (Staged) (Horde) -->
			<Do If="$(PublishHordeArtifacts)">
				<Node Name="$(PlatformStagedArtifactNodeName)" Requires="$(PlatformStageNodeName)">
					<Expand Name="WriteArtifactMetadataFile" Type="staged-build" Platform="$(StagedPlatformFolder)" Configuration="$(PackageConfigurations)" ArtifactDir="$(ProjectOutputDirectory)/$(StagedPlatformFolder)"/>
					<Tag Files="$(ProjectOutputDirectory)/$(StagedPlatformFolder)/..." With="#$(PlatformStageNodeName) Files"/>

					<CreateArtifact Name="$(ProjectName)-Staged-$(StagedPlatformFolder)" Type="staged-build" BaseDir="$(ProjectOutputDirectory)/$(StagedPlatformFolder)" Keys="Project=$(ProjectName)" Metadata="Stream=$(Branch);Platform=$(StagedPlatformFolder);BuildName=$(BuildNamePath);dashboard-category=Staged Builds" Files="#$(PlatformStageNodeName) Files"/>
				</Node>
			</Do>

			<!-- Package -->
			<Node Name="$(PlatformPackageNodeName)" Requires="$(PlatformPublishStageDependencyName)">
				<ForEach Name="PackageConfiguration" Values="$(PackageConfigurations)" Separator="+">
					<Command Name="BuildCookRun" Arguments="$(BCRArgs) -configuration=$(PackageConfiguration) $(StageAndPackageArguments) -skipbuild -skipcook -skipstage -skippak -package $(PackageOnlyArguments) -archive -archivedirectory=&quot;$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(PackageConfiguration)&quot;" />
				</ForEach>
			</Node>
			
			<!-- Publish (Packages) -->
			<Node Name="$(PlatformPublishPackagedNodeName)" Requires="$(PlatformPackageNodeName)">
				<Error Message="NetworkOutputDirectory is not set" If="'$(NetworkOutputDirectory)' == ''"/>
				<ForEach Name="PackageConfiguration" Values="$(PackageConfigurations)" Separator="+">
					<Command Name="BuildCookRun" Arguments="$(BCRArgs) -configuration=$(PackageConfiguration) $(StageAndPackageArguments) -skipbuild -skipcook -skipstage -skippak -skippackage -archive -archivedirectory=&quot;$(NetworkOutputDirectory)/$(StagedPlatformFolder)/Packages&quot;" />
				</ForEach>
			</Node>

			<!-- Publish (Packages) (Cloud) -->
			<Do  If="$(PublishCloudArtifacts)">
				<Property Name="CloudPackageSkipBCRArguments" Value="-stage -package"/>
				<Property Name="CloudPackageSkipBCRArguments" Value="-skipstage -skippackage" If="'$(TargetPlatform)' == 'Mac'"/>

				<Node Name="$(CloudArtifactPlatformPackagedNodeName)" Requires="$(PlatformPackageNodeName)">
					<ForEach Name="PackageConfiguration" Values="$(PackageConfigurations)" Separator="+">
						<Property Name="TargetDirectory" Value="$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(PackageConfiguration)"/>
						<Command Name="BuildCookRun" Arguments="$(BCRArgs) -configuration=$(PackageConfiguration) $(StageAndPackageArguments) -skipbuild -skipcook -skippak $(CloudPackageSkipBCRArguments) -archive -archivedirectory=&quot;$(TargetDirectory)&quot;" />
						<Expand Name="WriteArtifactMetadataFile" Type="packaged-build" Platform="$(StagedPlatformFolder)" Configuration="$(PackageConfiguration)" ArtifactDir="$(TargetDirectory)" />
						<Tag Files="$(TargetDirectory)/..." With="#$(PlatformPackageNodeName) $(PackageConfiguration) Files"/>

						<CreateCloudArtifact Name="$(BuildNamePath)-Packaged-$(PackageConfiguration)" HordeArtifactName="Cloud-$(ProjectName)-Packaged-$(StagedPlatformFolder)-$(PackageConfiguration)" Type="packaged-build" BaseDir="$(TargetDirectory)" Metadata="Configuration=$(PackageConfiguration);dashboard-category=Packaged Builds - Cloud" Project="$(TargetProject)" Platform="$(StagedPlatformFolder)" Files="#$(PlatformPackageNodeName) $(PackageConfiguration) Files"/>
						<Delete Files="$(TargetDirectory)/artifactmetadata.json"/>
					</ForEach>
				</Node>
			</Do>
			
			<!-- Publish (Packages) (Horde) -->
			<Do  If="$(PublishHordeArtifacts)">
				<Property Name="HordePackageSkipBCRArguments" Value="-stage -package"/>
				<Property Name="HordePackageSkipBCRArguments" Value="-skipstage -skippackage" If="'$(TargetPlatform)' == 'Mac'"/>

				<Node Name="$(HordeArtifactPlatformPackagedNodeName)" Requires="$(PlatformPackageNodeName)">
					<ForEach Name="PackageConfiguration" Values="$(PackageConfigurations)" Separator="+">
						<Command Name="BuildCookRun" Arguments="$(BCRArgs) -configuration=$(PackageConfiguration) $(StageAndPackageArguments) -skipbuild -skipcook -skippak $(HordePackageSkipBCRArguments) -archive -archivedirectory=&quot;$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(PackageConfiguration)&quot;" />
						<Expand Name="WriteArtifactMetadataFile" Type="packaged-build" Platform="$(StagedPlatformFolder)" Configuration="$(PackageConfiguration)" ArtifactDir="$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(PackageConfiguration)"/>
						<Tag Files="$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(PackageConfiguration)/..." With="#$(PlatformPackageNodeName) $(PackageConfiguration) Files"/>

						<CreateArtifact Name="$(ProjectName)-Packaged-$(StagedPlatformFolder)-$(PackageConfiguration)" Type="packaged-build" BaseDir="$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(PackageConfiguration)" Keys="Project=$(ProjectName)" Metadata="Stream=$(Branch);Platform=$(StagedPlatformFolder);Configuration=$(PackageConfiguration);BuildName=$(BuildNamePath);dashboard-category=$(PackageConfiguration) Builds" Files="#$(PlatformPackageNodeName) $(PackageConfiguration) Files"/>
					</ForEach>
				</Node>
			</Do>

			<!-- Check Build Size -->
			<Node Name="$(PlatformCheckBuildSizeNodeName)" Requires="$(PlatformPackageNodeName)">
				<ForEach Name="PackageConfiguration" Values="$(PackageConfigurations)" Separator="+">
					<Command Name="CheckBuildSize" Arguments="-project=$(TargetName) -platform=$(TargetPlatform) -packagesize=$(BuildSizeLimit) -build=&quot;$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(PackageConfiguration)&quot; -configuration=$(PackageConfiguration)" />
				</ForEach>
			</Node>
			
		</Agent>
		
		<!-- Test Time! -->
		<Property Name="AllPlatformInstallNodes" Value="" />
		<Property Name="AllPlatformBootTestNodes" Value="" />
		<Property Name="AllPlatformTestNodes" Value="" />

		<Property Name="UsePackaged" Value="(ContainsItem('$(PlatformsThatRequirePackaging)', '$(TargetPlatform)', '+') Or !ContainsItem('$(PlatformsToSkipPackaging)', '$(TargetPlatform)', '+'))" />

		<!-- Create the -build argument for Gauntlet based on whether builds are local or on the network-->
		<Property Name="GauntletBuildArg" Value="-build=&quot;$(ProjectOutputDirectory)/$(StagedPlatformFolder)&quot;" />
		<Property Name="GauntletBuildArg" Value="-build=&quot;$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)&quot; -packaged" If="$(UsePackaged)" />

		<Do If="!$(Horde) And ('$(NetworkOutputDirectory)' != '' Or '$(GeneratedBuildVersion)' != '')">
			<Property Name="TestDirectory" Value="$(NetworkOutputDirectory)" />
			<Property Name="TestDirectory" Value="$(GeneratedBuildDir)" If="'$(GeneratedBuildVersion)' != ''"/>
			<Property Name="GauntletBuildArg" Value="-build=&quot;$(TestDirectory)&quot;" />
			<Property Name="GauntletBuildArg" Value="$(GauntletBuildArg) -packaged" If="$(UsePackaged)" />
			<Property Name="GauntletBuildArg" Value="$(GauntletBuildArg) -destlocalinstalldir=&quot;$(LocalInstallDirectory)&quot;" If="!$(IsLocalPlatform) And $(WithDeviceReservation)"/>
		</Do>

		<!-- Test Configs -->
		<ForEach Name="TestConfig" Values="$(TestConfigList)" Separator="^">
			<Property Name="TestConfigTitle" Value=""/>
			<Regex Input="$(TestConfig)" Pattern="(.*)\|(.*)\|(.*)\|(.*)\|(.*)\|(.*)" Capture="TestConfigName;TestConfigTargetPlatform;ConfigArtifactPostfix;ConfigAdditionalTestArguments;ConfigAdditionalAppArguments;ConfigAgentType"/>

			<!--If this is the default test config i.e. "All" or Empty ensure we create nodes for it-->
			<Property Name="TestConfigTargetPlatform" Value="$(TargetPlatform)" If="'$(TestConfigTargetPlatform)' == 'All' Or '$(TestConfigTargetPlatform)' == ''"/>

			<Do If="'$(TestConfigTargetPlatform)' == '$(TargetPlatform)'">

				<Property Name="TestConfigTitle" Value=" $(TestConfigName)" If="'$(TestConfigName)' != ''"/>

				<Property Name="TestConfigArgs" Value="" />
				<Property Name="TestConfigArgs" Value="$(ConfigAdditionalTestArguments)" If="'$(ConfigAdditionalTestArguments)' != ''"/>
				<Property Name="TestConfigArgs" Value="$(TestConfigArgs) -ArtifactPostfix=$(ConfigArtifactPostfix)" If="'$(ConfigArtifactPostfix)' != ''"  />
				<Property Name="TestConfigArgs" Value="$(TestConfigArgs) -args=&quot;$(ConfigAdditionalAppArguments)&quot;" If="'$(ConfigAdditionalAppArguments)' != ''" />

				<Property Name="TestTargetAgentType" Value="$(TestAgentType)"/>
				<Property Name="TestTargetAgentType" Value="$(ConfigAgentType)" If="'$(ConfigAgentType)' != ''"/>

				<Agent Name="Test$(TestConfigTitle) $(PlatformAgentName)" Type="$(TestTargetAgentType)">
					<!-- Run through all configs -->
					<ForEach Name="TestConfiguration" Values="$(TestConfigurations)" Separator="+">
						<Property Name="NodeAnnotations" Value=""/>
						<!-- Prerequisites for the test to run -->
						<Property Name="TestPrerequisites" Value="$(RequirePlatformStaged)" />
						<Property Name="TestPrerequisites" Value="$(RequirePlatformPackaged)" If="$(UsePackaged)"/>
						<Property Name="TestPrerequisites" Value="$(PlatformToolsNodeName)" If="'$(GeneratedBuildVersion)' != ''"/>
						<Property Name="TestPrerequisites" Value="$(PlatformToolsNodeName);$(PlatformEditorNodeName)" If="'$(GeneratedBuildVersion)' != '' and $(TestsRequireEditor)"/>

						<Do If="$(PublishHordeArtifacts) and !$(RetrieveUsingCloudArtifacts)">
							<Property Name="HordeArtifactPlatformRetrieveWithConfig" Value="$(HordeArtifactPlatformRetrieve) $(TestConfiguration)$(TestConfigTitle) (Horde)"/>
							<Node Name="$(HordeArtifactPlatformRetrieveWithConfig)" Requires="$(TestPrerequisites)">
								<Switch>
									<Case If="$(UsePackaged)">
										<RetrieveArtifact Name="$(ProjectName)-Packaged-$(StagedPlatformFolder)-$(TestConfiguration)" Type="packaged-build" OutputDir="$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(TestConfiguration)" />
									</Case>
									<Default>
										<RetrieveArtifact Name="$(ProjectName)-Staged-$(StagedPlatformFolder)" Type="staged-build" OutputDir="$(ProjectOutputDirectory)/$(StagedPlatformFolder)" />
									</Default>
								</Switch>
							</Node>
							<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(HordeArtifactPlatformRetrieveWithConfig)" />
						</Do>

						<Do If="$(RetrieveUsingCloudArtifacts)">
							<Property Name="CloudArtifactPlatformRetrieveWithConfig" Value="$(CloudArtifactPlatformRetrieve) $(TestConfiguration)$(TestConfigTitle) (Cloud)"/>
							<Node Name="$(CloudArtifactPlatformRetrieveWithConfig)" Requires="$(TestPrerequisites)">
								<Switch>
									<Case If="$(UsePackaged)">
										<RetrieveCloudArtifact Name="$(BuildNamePath)-Packaged-$(TestConfiguration)" Type="packaged-build" OutputDir="$(ProjectOutputDirectory)/Packages/$(StagedPlatformFolder)/$(TestConfiguration)" Project="$(TargetProject)" Platform="$(StagedPlatformFolder)" />
									</Case>
									<Default>
										<RetrieveCloudArtifact Name="$(BuildNamePath)-Staged" Type="staged-build" OutputDir="$(ProjectOutputDirectory)/$(StagedPlatformFolder)" Project="$(TargetProject)" Platform="$(StagedPlatformFolder)" />
									</Default>
								</Switch>
							</Node>

							<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(CloudArtifactPlatformRetrieveWithConfig)" />
						</Do>

						<Property Name="GauntletTestArgs" Value="$(GauntletTargetTestArgs)"/>
						<Property Name="GauntletTestArgs" Value="$(GauntletTargetTestAltArgs)" If="ContainsItem('$(AlternateDevicePoolPlatforms)', '$(TargetPlatform)', ';')"/>

						<Property Name="GauntletTestArgs" Value="$(GauntletTestArgs) -adbkeys=&quot;$(AdbKeysPath)&quot;" If="'$(AdbKeysPath)' != '' and '$(TargetPlatform)' == 'Android'"/>

						<!-- Install step -->
						<Do If="!$(IsLocalPlatform) And $(WithDeviceReservation)">
							<Property Name="NodeAnnotations" Value=""/>
							<Property Name="NodeAnnotations" Value="Workflow=$(AnnotationsTarget)" If="ContainsItem('$(AnnotationsPlatforms)', '$(TargetPlatform)', ';') and ContainsItem('$(AnnotationsTests)', 'Install', ';')"/>
							<Property Name="InstallNodeName" Value="$(PreNodeName)$(TargetPlatform) $(TestConfiguration)$(TestConfigTitle) Install Game"/>
							<Property Name="InstallArgs" Value="-ClientCount=1 $(GauntletPreInstallArgs)"/>
							<Do If="'$(AutomationReportOutputDirectory)' != ''">
								<Property Name="OutputFragmentPath" Value="$(TargetPlatform)/$(TestConfiguration)/UE.InstallOnly" />
								<Property Name="OutputReportPath" Value="$(AutomationReportOutputDirectory)/$(OutputFragmentPath)" />
								<Property Name="GauntletReportArgs" Value="-logdir=&quot;$(OutputReportPath)&quot; -artifactname=Gauntlet" />
							</Do>
							<Node Name="$(InstallNodeName)" Requires="$(TestPrerequisites)" Annotations="DeviceReserve=Begin;$(NodeAnnotations)">
								<Command Name="RunUnreal" Arguments="-project=$(TargetProject) -test=&quot;UE.InstallOnly&quot; -platform=$(TargetPlatform) -configuration=$(TestConfiguration) -target=$(TargetName) $(GauntletBuildArg) $(GauntletTestArgs) $(GauntletReportArgs) $(InstallArgs)" />
							</Node>
							<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(InstallNodeName)" />
							<Do If="!ContainsItem('$(TargetPlatformsToSkipBootTests)', '$(TargetPlatform)', '+') Or !ContainsItem('$(TargetPlatformsToSkipTests)', '$(TargetPlatform)', '+')">
								<Property Name="AllPlatformInstallNodes" Value="$(AllPlatformInstallNodes);$(InstallNodeName)"/>
							</Do>
							<!-- Skip install for all other test node -->
							<Property Name="GauntletTestArgs" Value="$(GauntletTestArgs) $(GauntletTestSkipInstallArgs)"/>
						</Do>

						<!-- Declare a boot test for the target-->
						<Property Name="NodeAnnotations" Value=""/>
						<Property Name="NodeAnnotations" Value="Workflow=$(AnnotationsTarget)" If="ContainsItem('$(AnnotationsPlatforms)', '$(TargetPlatform)', ';') and ContainsItem('$(AnnotationsTests)', 'BootTest', ';')"/>
						<Property Name="BootTestName" Value="$(PreNodeName)$(TargetPlatform) $(TestConfiguration)$(TestConfigTitle) BootTest" />
						<Node Name="$(BootTestName)" Requires="$(TestPrerequisites)" Annotations="$(NodeAnnotations)">
							<Do If="'$(AutomationReportOutputDirectory)' != ''">
								<Property Name="OutputFragmentPath" Value="$(TargetPlatform)/$(TestConfiguration)/UE.BootTest" />
								<Property Name="OutputReportPath" Value="$(AutomationReportOutputDirectory)/$(OutputFragmentPath)" />
								<Property Name="GauntletReportArgs" Value="-logdir=&quot;$(OutputReportPath)&quot; -artifactname=Gauntlet" />
							</Do>
							<!-- Run the boot test -->
							<Command Name="RunUnreal" Arguments="-project=$(TargetProject) -test=&quot;UE.BootTest&quot; -platform=$(TargetPlatform) -configuration=$(TestConfiguration) -target=$(TargetName) $(GauntletBuildArg) $(GauntletTestArgs) $(GauntletReportArgs) $(TestConfigArgs)" />
						</Node>
						<!-- Link the boot test in to the prerequisites and generated nodes if its enabled-->
						<Do If="$(TargetBootTest) and !ContainsItem('$(TargetPlatformsToSkipBootTests)', '$(TargetPlatform)', '+')">
							<Property Name="TestPrerequisites" Value="$(TestPrerequisites);$(BootTestName)" />
							<Property Name="AllPlatformBootTestNodes" Value="$(AllPlatformBootTestNodes);$(BootTestName)"/>
						</Do>

						<!-- Go through the list of tests -->
						<ForEach Name="TestName" Values="$(TargetTestList)" Separator="+">
							<Property Name="TestNameTitle" Value="$(TestName)"/>
							<Expand Name="SanitizeTestNameTitle"/>
							<!-- Run and report on the test-->
							<Do If="'$(AutomationReportOutputDirectory)' != ''">
								<Property Name="OutputFragmentPath" Value="$(TargetPlatform)/$(TestConfiguration)/$(TestNameTitle)" />
								<Property Name="OutputReportPath" Value="$(AutomationReportOutputDirectory)/$(OutputFragmentPath)" />
								<Property Name="GauntletReportArgs" Value="-logdir=&quot;$(OutputReportPath)&quot; -artifactname=Gauntlet -ReportExportPath=&quot;$(OutputReportPath)&quot;" />
								<Property Name="GauntletReportArgs" Value="$(GauntletReportArgs) -ReportURL=&quot;$(AutomationReportUrl)/$(OutputFragmentPath)/&quot;" If="'$(AutomationReportUrl)' != ''" />
							</Do>
							<Property Name="TestNodeName" Value="$(PreNodeName)$(TargetPlatform) $(TestConfiguration)$(TestConfigTitle) $(TestNameTitle)" />
							<Property Name="NodeAnnotations" Value=""/>
							<Property Name="NodeAnnotations" Value="Workflow=$(AnnotationsTarget)" If="ContainsItem('$(AnnotationsPlatforms)', '$(TargetPlatform)', ';') and ContainsItem('$(AnnotationsTests)', '$(TestName)', ';')"/>

							<Property Name="TestNameBeforeParentheses" Value="$(TestName)"/>
							<Property Name="TestArgumentsWithinParentheses" Value=""/>
							<Expand Name="SplitCombinedTestNameAndArgs"/>

							<!-- Test 'Requires' should be the package game and the publish folder is used; however some tests may require the editor ie: UE.TargetAutomation -->
							<Property Name="AdditionalTestPrerequisites" Value=""/>
							<ForEach Name="ToMatchName" Values="$(RequiringEditorTargetTestList)" Separator="+">
								<Do If="Contains('$(TestNameBeforeParentheses)', '$(ToMatchName)') And !ContainsItem('$(TestPrerequisites)', '$(PlatformEditorNodeName)', ';')">
									<Property Name="AdditionalTestPrerequisites" Value="$(AdditionalTestPrerequisites);$(PlatformEditorNodeName)" />
								</Do>
							</ForEach>

							<!-- 'Requires' should be the package game and the publish folder is used; however some tests may require the editor ie: UE.TargetAutomation -->
							<Node Name="$(TestNodeName)" Requires="$(TestPrerequisites);$(AdditionalTestPrerequisites)" Annotations="$(NodeAnnotations)">
								<Command Name="RunUnreal" Arguments="-project=$(TargetProject) -test=&quot;$(TestNameBeforeParentheses)&quot; -platform=$(TargetPlatform) -configuration=$(TestConfiguration) -target=$(TargetName) $(GauntletBuildArg) $(GauntletTestArgs) $(TestArgumentsWithinParentheses) $(GauntletReportArgs) $(TestConfigArgs)"/>
							</Node>
							<!-- Add it to our list -->
							<Do If="!ContainsItem('$(TargetPlatformsToSkipTests)', '$(TargetPlatform)', '+')">
								<Property Name="AllPlatformTestNodes" Value="$(AllPlatformTestNodes);$(TestNodeName)"/>
							</Do>
						</ForEach>

						<!-- Expand the tests here -->
						<Expand Name="AdditionalTestNodes"/>
					</ForEach>
				</Agent>
			</Do>
		</ForEach>
		
		<!-- Declare labels for CIS -->
		<Label Category="Clients" Name="$(PreLabelName)$(TargetPlatform)" Requires="$(PlatformCompileNodeName);$(UploadSymbolsNodeName)" />
		<Label Category="Clients" Name="$(PreLabelName)Content $(TargetPlatform)" Requires="$(PlatformCookNodeName);$(PlatformStageNodeName);$(PlatformPackageNodeName)" />
		<Label Category="Clients" Name="$(PreLabelName)Publish $(TargetPlatform)" Requires="$(PlatformPublishPackagedNodeName);$(PlatformPublishPackagedNodeName);$(PlatformPublishStagedNodeName);$(PlatformHashNodeName)" />
		<Label Category="Tests" Name="$(PreLabelName)Install $(TargetPlatform)" Requires="$(AllPlatformInstallNodes)" />
		<Label Category="Tests" Name="$(PreLabelName)BootTest $(TargetPlatform)" Requires="$(AllPlatformBootTestNodes)" />
		<Label Category="Tests" Name="$(PreLabelName)Test $(TargetPlatform)" Requires="$(AllPlatformTestNodes)" />

		<!-- Tie all steps into our platform tasks unless excluded -->
		<Property Name="PlatformTasks" Value="" />
		<Property Name="PlatformTasks" Value="$(PlatformCompileNodeName);$(UploadSymbolsNodeName)" If="!$(SkipBuild)" />
		<Property Name="PlatformTasks" Value="$(PlatformTasks);$(PlatformCookNodeName)" If="!$(SkipCook) and !$(SkipPublish)" />
		<Property Name="PlatformTasks" Value="$(PlatformTasks);$(RequirePlatformStaged)" If="!$(SkipPublish)" />
		<Property Name="PlatformTasks" Value="$(PlatformTasks);$(RequirePlatformPackaged)" If="!$(SkipPackage) and !$(SkipPublish)" />
		<Property Name="PlatformTasks" Value="$(PlatformTasks);$(PlatformHashNodeName)"  If="$(PublishHashedStagingData)" />	
		<Property Name="PlatformTasks" Value="$(PlatformTasks);$(AllPlatformBootTestNodes);$(AllPlatformTestNodes)" />
		<Property Name="PlatformTasks" Value="$(PlatformTasks);$(PlatformCheckBuildSizeNodeName)" If="'$(BuildSizeLimit)' != ''" />

		<Property Name="GeneratedTargetNodes" Value="$(GeneratedTargetNodes);$(PlatformTasks)"/>
		<Property Name="GeneratedTargetTestNodes" Value="$(GeneratedTargetTestNodes);$(AllPlatformBootTestNodes);$(AllPlatformTestNodes)"/>
	</ForEach>

	<!-- Create an aggregate with all the generated nodes -->
	<Aggregate Name="BuildAndTest $(ProjectName)" Requires="$(GeneratedToolNodes);$(GeneratedCookedEditorNodes);$(GeneratedEditorTestNodes);$(GeneratedCookedEditorTestNodes);$(GeneratedTargetNodes);$(GeneratedTargetTestNodes)"/>
	<Aggregate Name="OnlyTest $(ProjectName)" Requires="$(GeneratedEditorTestNodes);$(GeneratedCookedEditorTestNodes);$(GeneratedTargetTestNodes)"/>

	
</BuildGraph>